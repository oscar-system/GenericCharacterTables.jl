var documenterSearchIndex = {"docs":
[{"location":"tables/","page":"Tables","title":"Tables","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"tables/#Tables","page":"Tables","title":"Tables","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"This section describes how to instantiate generic character tables and tables of Green functions, as well as various functions for accessing properties of these tables.","category":"page"},{"location":"tables/#Loading-tables","page":"Tables","title":"Loading tables","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"Before doing anything you need to load a table first. GenericCharacterTables comes with a variety of precomputed tables.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"genchartab","category":"page"},{"location":"tables/#GenericCharacterTables.genchartab","page":"Tables","title":"GenericCharacterTables.genchartab","text":"genchartab(x::String)\n\nReturn the generic character table with name x.\n\nOmitting x will return the names of all importable character tables.\n\nExamples\n\njulia> g = genchartab(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\n\n\n\n\n","category":"function"},{"location":"tables/","page":"Tables","title":"Tables","text":"GenericCharacterTables also provides some tables of Green functions. They can be loaded similarly.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"greenfuntab","category":"page"},{"location":"tables/#GenericCharacterTables.greenfuntab","page":"Tables","title":"GenericCharacterTables.greenfuntab","text":"greenfuntab(x::String)\n\nReturn the greenfunction table with name x.\n\nOmitting x will return the names of all importable greenfunctions.\n\nExamples\n\njulia> g = greenfuntab(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 2 irreducible character types\n  with 2 class types\n  without parameters\n\n\n\n\n\n","category":"function"},{"location":"tables/#Properties","page":"Tables","title":"Properties","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"info\nnumber_of_characters(t::Table)\nnrparams\nparams\norder(t::Table)","category":"page"},{"location":"tables/#GenericCharacterTables.info","page":"Tables","title":"GenericCharacterTables.info","text":"info(t::Table)\n\nReturn the metadata of t in LaTeX format. This usually includes the time the table was first computed.\n\n\n\n\n\n","category":"function"},{"location":"tables/#GenericCharacterTables.number_of_characters-Tuple{GenericCharacterTables.Table}","page":"Tables","title":"GenericCharacterTables.number_of_characters","text":"number_of_characters(t::Table)\n\nReturn the number of irreducible characters of table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> number_of_characters(g)\nq^2 - 1\n\n\n\n\n\n\n","category":"method"},{"location":"tables/#GenericCharacterTables.nrparams","page":"Tables","title":"GenericCharacterTables.nrparams","text":"nrparams(t::CharTable)\n\nReturn the number of class and character parameters of the table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> nrparams(g)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"tables/#GenericCharacterTables.params","page":"Tables","title":"GenericCharacterTables.params","text":"params(t::CharTable)\n\nReturn all parameters the table t depends on.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> params(g)\n(q, (i, j, l, k))\n\n\n\n\n\n\nparams(char::AbstractGenericCharacter)\n\nReturn the parameters of the character type char. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> params(g[3])\nk ‚àà {1,‚Ä¶, q - 1}, l ‚àà {1,‚Ä¶, q - 1} except -l + k ‚àà (q - 1)‚Ñ§\n\n\n\n\n\n","category":"function"},{"location":"tables/#AbstractAlgebra.order-Tuple{GenericCharacterTables.Table}","page":"Tables","title":"AbstractAlgebra.order","text":"order(t::Table)\n\nReturn the order of the table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> order(g)\nq^4 - q^3 - q^2 + q\n\n\n\n\n\n","category":"method"},{"location":"tables/#Iteration","page":"Tables","title":"Iteration","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"Tables implement Julia's iteration interface to iterate over the irreducible character types stored in the table. For a table T,","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"length(T) returns the number of character types in the table,\nT[i] returns the ith character type.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"For example we can use this to compute the order of the underlying group type. (Of course this can also be checked via order, which retrieves a precomputed value.)","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"julia> g=genchartab(\"GL2\");\n\njulia> sum(number_of_characters(c)*degree(c)^2 for c in g)\nq^4 - q^3 - q^2 + q\n\njulia> order(g)\nq^4 - q^3 - q^2 + q","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"M.¬†Geck, G.¬†Hiss, F.¬†L√ºbeck, G.¬†Malle and G.¬†Pfeiffer. CHEVIE‚Äîa system for computing and processing generic character tables. Appl.¬†Algebra¬†Engrg.¬†Comm.¬†Comput. 7, 175‚Äì210 (1996). Computational methods in Lie theory (Essen, 1994).\n\n\n\nThe Computer Algebra System OSCAR: Algorithms and Examples. Vol.¬†32 of Algorithms and Computation in Mathematics (Springer, 2024).\n\n\n\n","category":"page"},{"location":"unexported/","page":"Unexported Functions","title":"Unexported Functions","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"unexported/#Unexported-Functions","page":"Unexported Functions","title":"Unexported Functions","text":"","category":"section"},{"location":"unexported/","page":"Unexported Functions","title":"Unexported Functions","text":"These are all functions for internal use only:","category":"page"},{"location":"unexported/","page":"Unexported Functions","title":"Unexported Functions","text":"Modules = [GenericCharacterTables]\nPublic = false","category":"page"},{"location":"unexported/#GenericCharacterTables.CharTable","page":"Unexported Functions","title":"GenericCharacterTables.CharTable","text":"CharTable <: Table\n\nThe type for generic character tables. This is used to model generic character tables containing generic cyclotomic entries.\n\nExamples\n\njulia> g=genchartab(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.CharTable-Tuple{GenericCharacterTables.GenericCharacter}","page":"Unexported Functions","title":"GenericCharacterTables.CharTable","text":"(t::CharTable)(c::GenericCharacter)\n\nReturn c as a generic character of t. This will only work if t is a version of the parent table of c with a more restricted congruence.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.GenericCharacter","page":"Unexported Functions","title":"GenericCharacterTables.GenericCharacter","text":"GenericCharacter <: AbstractGenericCharacter\n\nThe type for generic characters. These are the generic characters used in CharTable.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> g[1]\nGeneric character of GL2\n  with parameters\n    k ‚àà {1,‚Ä¶, q - 1}\n  of degree 1\n  with values\n    exp(2œÄùëñ((2*i*k)//(q - 1)))\n    exp(2œÄùëñ((2*i*k)//(q - 1)))\n    exp(2œÄùëñ((i*k + j*k)//(q - 1)))\n    exp(2œÄùëñ((i*k)//(q - 1)))\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericCyclo","page":"Unexported Functions","title":"GenericCharacterTables.GenericCyclo","text":"GenericCyclo <: RingElem\n\nThe type for generic cyclotomic numbers.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S = generic_cyclotomic_ring(R);\n\njulia> S(q; exponent=1//(q-1))\nq*exp(2œÄùëñ(1//(q - 1)))\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericCycloFrac","page":"Unexported Functions","title":"GenericCharacterTables.GenericCycloFrac","text":"GenericCycloFrac\n\nThe type for fractions of generic cyclotomic numbers.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S = generic_cyclotomic_ring(R);\n\njulia> a = S(q; exponent=1//(q-1))\nq*exp(2œÄùëñ(1//(q - 1)))\n\njulia> b = S(q^2; exponent=1//(q^2-1))\nq^2*exp(2œÄùëñ(1//(q^2 - 1)))\n\njulia> a//b\nq*exp(2œÄùëñ(1//(q - 1)))//(q^2*exp(2œÄùëñ(1//(q^2 - 1))))\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericCycloRing","page":"Unexported Functions","title":"GenericCharacterTables.GenericCycloRing","text":"GenericCycloRing <: Ring\n\nThe ring of generic cyclotomic numbers.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S = generic_cyclotomic_ring(R)\nGeneric cyclotomic ring\n  over Rational field\n  dependent on q\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.Parameter","page":"Unexported Functions","title":"GenericCharacterTables.Parameter","text":"Parameter\n\nA paramter of a generic character or class type unique up to a polynomial modulus. They are used in Parameters.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.ParameterExceptions","page":"Unexported Functions","title":"GenericCharacterTables.ParameterExceptions","text":"ParameterExceptions\n\nA collection of parameter exceptions used in GenericCycloFrac.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.ParameterSubstitution","page":"Unexported Functions","title":"GenericCharacterTables.ParameterSubstitution","text":"ParameterSubstitution\n\nA substitution of paramters used in Parameters. They are generated by for example specclassparam!.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.Parameters","page":"Unexported Functions","title":"GenericCharacterTables.Parameters","text":"Parameters\n\nParameters of generic characters and class types. This is used in GenericCharacter and CharTable and is only of internal use.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.SimpleCharTable","page":"Unexported Functions","title":"GenericCharacterTables.SimpleCharTable","text":"SimpleCharTable{T} <: Table\n\nThe type for simple generic character tables. This is used to model generic character tables containing polynomial entries. The type parameter T is the type of the table entries.\n\nExamples\n\njulia> g=genchartab(\"uniGL2\")\nGeneric character table uniGL2\n  of order q^4 - q^3 - q^2 + q\n  with 2 irreducible character types\n  with 4 class types\n  without parameters\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.SimpleGenericCharacter","page":"Unexported Functions","title":"GenericCharacterTables.SimpleGenericCharacter","text":"SimpleGenericCharacter <: AbstractGenericCharacter\n\nThe type for simple generic characters. These are the generic characters used in SimpleCharTable.\n\nExamples\n\njulia> g=genchartab(\"uniGL2\")\nGeneric character table uniGL2\n  of order q^4 - q^3 - q^2 + q\n  with 2 irreducible character types\n  with 4 class types\n  without parameters\n\njulia> g[1]\nGeneric character of uniGL2\n  of degree q\n  with values\n    q\n    0\n    1\n    -1\n\n\n\n\n\n","category":"type"},{"location":"unexported/#AbstractAlgebra.Generic.normal_form-Tuple{AbstractAlgebra.Generic.UnivPoly{Nemo.ZZRingElem, AbstractAlgebra.Generic.MPoly{Nemo.ZZRingElem}}, Int64}","page":"Unexported Functions","title":"AbstractAlgebra.Generic.normal_form","text":"normal_form(f::AbstractAlgebra.Generic.UnivPoly{ZZRingElem, AbstractAlgebra.Generic.MPoly{ZZRingElem}}, m::Int64)\n\nReturn a normal form of f modulo m, such that normal_form(f,m) is equal to normal_form(g,m) if and only if f and g are congruent modulo m.\n\nExamples\n\njulia> R=universal_polynomial_ring(ZZ);\n\njulia> x=gen(R, :x);\n\njulia> normal_form(4*x^2,6)\nx^2 + 3*x\n\njulia> normal_form(4*x^2-(x^2+3*x),6)\n0\n\njulia> normal_form(4*x^9+x^7,12)\nx^3 + 4*x\n\njulia> normal_form(4*x^9+x^7-(x^3+4*x),12)\n0\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.iszero-Tuple{GenericCharacterTables.GenericCycloFrac}","page":"Unexported Functions","title":"Base.iszero","text":"iszero(x::GenericCycloFrac; ignore_exceptions::Bool=false)\n\nReturn if x is zero. If ignore_exceptions is true then the exceptions of x will not be considered.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, GenericCharacterTables.AbstractGenericCharacter}","page":"Unexported Functions","title":"Base.show","text":"show(io::IO, c::AbstractGenericCharacter)\n\nDisplay a summary of the generic character c.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> g[3]\nGeneric character of GL2\n  with parameters\n    k ‚àà {1,‚Ä¶, q - 1}, l ‚àà {1,‚Ä¶, q - 1} except -l + k ‚àà (q - 1)‚Ñ§\n  of degree q + 1\n  with values\n    (q + 1)*exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n    exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n    exp(2œÄùëñ((i*l + j*k)//(q - 1))) + exp(2œÄùëñ((i*k + j*l)//(q - 1)))\n    0\n\njulia> [g[3]]\n1-element Vector{GenericCharacterTables.GenericCharacter}:\n Generic character of GL2\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, GenericCharacterTables.Table}","page":"Unexported Functions","title":"Base.show","text":"show(io::IO, t::Table)\n\nDisplay a summary of the generic character table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\njulia> [g]\n1-element Vector{GenericCharacterTables.CharTable}:\n Generic character table GL2\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.add_exception!-Tuple{GenericCharacterTables.ParameterExceptions, AbstractAlgebra.Generic.FracFieldElem{AbstractAlgebra.Generic.UnivPoly{Nemo.QQFieldElem, AbstractAlgebra.Generic.MPoly{Nemo.QQFieldElem}}}}","page":"Unexported Functions","title":"GenericCharacterTables.add_exception!","text":"add_exception!(a::ParameterExceptions, exception::UPolyFrac)\n\nInclude exception into a. This also removes all now redundant exceptions from a.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.is_integer-Tuple{AbstractAlgebra.Generic.FracFieldElem{AbstractAlgebra.Generic.UnivPoly{Nemo.QQFieldElem, AbstractAlgebra.Generic.MPoly{Nemo.QQFieldElem}}}}","page":"Unexported Functions","title":"GenericCharacterTables.is_integer","text":"is_integer(x::UPolyFrac)\n\nReturn if x represents an integer.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.is_restriction-Tuple{GenericCharacterTables.ParameterExceptions}","page":"Unexported Functions","title":"GenericCharacterTables.is_restriction","text":"is_restriction(x::ParameterExceptions)\n\nReturn if x actually restricts something.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.merge-Tuple{GenericCharacterTables.ParameterExceptions, GenericCharacterTables.ParameterExceptions}","page":"Unexported Functions","title":"GenericCharacterTables.merge","text":"merge(x::ParameterExceptions, y::ParameterExceptions)\n\nReturn a new collection of parameter exceptions composed of x and y where all redundant exceptions are omitted.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.shift_char_parameters-Tuple{GenericCharacterTables.CharTable, Union{GenericCharacterTables.GenericCyclo, GenericCharacterTables.GenericCycloFrac, GenericCharacterTables.Parameters}, Int64}","page":"Unexported Functions","title":"GenericCharacterTables.shift_char_parameters","text":"shift_char_parameters(t::CharTable, a::Union{Parameters,GenericCyclo,GenericCycloFrac}, steps::Int64)\n\nReplace all character parameters of t in a by their counterparts suffixed with steps.\n\nThis is done by shifting them steps*nrparams(t) steps further in t.argumentring.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.shift_class_parameters-Tuple{GenericCharacterTables.CharTable, Union{GenericCharacterTables.GenericCyclo, GenericCharacterTables.GenericCycloFrac, GenericCharacterTables.Parameters}, Int64}","page":"Unexported Functions","title":"GenericCharacterTables.shift_class_parameters","text":"shift_class_parameters(t::CharTable, a::Union{Parameters,GenericCyclo,GenericCycloFrac}, steps::Int64)\n\nReplace all class parameters of t in a by their counterparts suffixed with steps.\n\nThis is done by shifting them steps*nrparams(t) steps further in t.argumentring.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.shrink-Tuple{GenericCharacterTables.GenericCycloFrac}","page":"Unexported Functions","title":"GenericCharacterTables.shrink","text":"shrink(a::GenericCycloFrac{<:NfPoly})\n\nRemove exceptions from a that follow from the others. And try to simplify the representation of a.\n\n\n\n\n\n","category":"method"},{"location":"book/","page":"An extended example","title":"An extended example","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"book/#An-extended-example","page":"An extended example","title":"An extended example","text":"","category":"section"},{"location":"book/","page":"An extended example","title":"An extended example","text":"The following is based on an example in [OSCAR], which in turn is based on Section 5.3 of [GHLMP96]. To fully understand what is going on we strongly recommend to read the latter source concurrently with the present text.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"To start we load the generic character table for mathrmSL_3(q) with qnotequiv 1pmod 3. To learn about the origin of the table, we could enter print(info(T)).","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> T = genchartab(\"SL3.n1\")\nGeneric character table SL3.n1\n  of order q^8 - q^6 - q^5 + q^3\n  with 8 irreducible character types\n  with 8 class types\n  with parameters (a, b, m, n)","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"As we can see this table has four parameters in addition to q. The entries of the table are ‚Äúgeneralized cyclotomics‚Äù, that is, linear combinations over mathbbQ(q) of symbolic ‚Äúroots of unity‚Äù depending on the parameters listed above.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> T[4,4]\n(q + 1)*exp(2œÄùëñ((a*n)//(q - 1))) + exp(2œÄùëñ((-2*a*n)//(q - 1)))","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Denoting row 4 of the table by chi_4, we note that is not a single character, but a character type, describing a whole family of characters.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> œá‚ÇÑ = T[4]\nGeneric character of SL3.n1\n  with parameters\n    n ‚àà {1,‚Ä¶, q - 1} except n ‚àà (q - 1)‚Ñ§\n  of degree q^2 + q + 1\n  with values\n    q^2 + q + 1\n    q + 1\n    1\n    (q + 1)*exp(2œÄùëñ((a*n)//(q - 1))) + exp(2œÄùëñ((-2*a*n)//(q - 1)))\n    exp(2œÄùëñ((a*n)//(q - 1))) + exp(2œÄùëñ((-2*a*n)//(q - 1)))\n    exp(2œÄùëñ((a*n)//(q - 1))) + exp(2œÄùëñ((b*n)//(q - 1))) + exp(2œÄùëñ((-a*n - b*n)//(q - 1)))\n    exp(2œÄùëñ((a*n)//(q - 1)))\n    0","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"With these generic characters, we can compute norms, scalar products, and more. For this demonstration we tensor the second character type chi_2 with itself.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> h = T[2] * T[2]\nGeneric character of SL3.n1\n  of degree q^4 + 2*q^3 + q^2\n  with values\n    q^4 + 2*q^3 + q^2\n    q^2\n    0\n    q^2 + 2*q + 1\n    1\n    4\n    0\n    1","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"We may now attempt to decompose this character type h by computing its scalar product with the irreducible character types. This returns a ‚Äúgeneric‚Äù scalar product, plus a (possibly empty) list of parameter exceptions for which the general result may not hold. For example:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> scalar_product(T[4], h)\n0\nWith exceptions:\n  2*n1 ‚àà (q - 1)‚Ñ§","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"This scalar product is 0 except when q-1 divides 2n_1, where n_1 indicates the value of the parameter n for the first factor in the scalar product (i.e. the character type chi_4). For a ‚Äúgeneric decomposition‚Äù we need to compute all the scalar products and exceptions.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> for i in 1:8 println(\"<$i, h> = \", scalar_product(T[i], h)) end\n<1, h> = 1\n<2, h> = 2\n<3, h> = 2\n<4, h> = 0\nWith exceptions:\n  2*n1 ‚àà (q - 1)‚Ñ§\n<5, h> = 0\nWith exceptions:\n  2*n1 ‚àà (q - 1)‚Ñ§\n<6, h> = 0\nWith exceptions:\n  2*m1 - n1 ‚àà (q - 1)‚Ñ§\n  m1 - 2*n1 ‚àà (q - 1)‚Ñ§\n  m1 + n1 ‚àà (q - 1)‚Ñ§\n  m1 ‚àà (q - 1)‚Ñ§\n  m1 - n1 ‚àà (q - 1)‚Ñ§\n  n1 ‚àà (q - 1)‚Ñ§\n<7, h> = 0\nWith exceptions:\n  n1 ‚àà (q - 1)‚Ñ§\n<8, h> = 0\nWith exceptions:\n  q*n1 ‚àà (q^2 + q + 1)‚Ñ§\n  n1 ‚àà (q^2 + q + 1)‚Ñ§\n  q*n1 + n1 ‚àà (q^2 + q + 1)‚Ñ§","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"This suggest a decomposition of chi_2otimeschi_2 into chi_1+2chi_2+2chi_3 ‚Äúin general‚Äù. But comparing the respective degrees, we notice a discrepancy:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> degree(lincomb([1,2,2],[T[1],T[2],T[3]]))\n2*q^3 + 2*q^2 + 2*q + 1\n\njulia> degree(h)\nq^4 + 2*q^3 + q^2","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"To resolve this, we need to work through the exceptions. Recall that earlier we saw that langlechi_4chi_2^2rangle=0 except when q-1 divides 2n_1, where n_1 was the value of the parameter n used in chi_4. Further restrictions apply to n:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> params(T[4])\nn ‚àà {1,‚Ä¶, q - 1} except n ‚àà (q - 1)‚Ñ§","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"So n may take on any value between 1 and q-1 not divisible by q-1. Hence the only possible exception is n=(q-1)2 which can only occur if q is odd. It thus makes sense to consider q odd and q even separately.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"We demonstrate this for q even. Then langlechi_4chi_2^2rangle=0 and with a similar argument langlechi_5chi_2^2rangle=0. We now construct a copy of the table but with the congruence equation qequiv 0pmod 2 applied:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> T2 = setcongruence(T; remainder=0, modulus=2);","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Inspecting the list of exceptions for langlechi_6chi_2^2rangle, the first occurs when q-1 divides m+n. To study this case we specialize m for character type 6:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> (q, (a, b, m, n)) = params(T2);\n\njulia> x = param(T2, \"x\");  # create an additional \"free\" variable\n\njulia> s = specialize(T2[6], m, -n + (q-1)*x);  # force m = -n (mod q-1)","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Recomputing the scalar product now gives a new result. Note that we have to map the character type h into the new table for this to work.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> scalar_product(s, T2(h))\n1\nWith exceptions:\n  3*n1 ‚àà (q - 1)‚Ñ§\n  2*n1 ‚àà (q - 1)‚Ñ§","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"The exceptions both cannot occur as q is even and the table we are considering is only defined for qnotequiv 1pmod 3. By working through the other possible exceptions and irreducible character types, and handling duplicates, one finally obtains","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"chi_2^2 = chi_1+2chi_2+2chi_3\n    +frac12sum_n=1^q-2 chi_6(nq-1-n)\n    +frac12sum_n=1^q chi_7(n(q-1))","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Where chi_6(nq-1-n) indicates that the 6th character in the table T2 is a family on two parameters: n and q-1-n, while chi_7 depends on only one, namely n(q-1). A similar result can be obtained for odd q albeit with a few more cases that need to be dealt with, but all in essentially the same manner.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"characters/#Character-types","page":"Character types","title":"Character types","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"A character type is a family of characters which are indexed by a set of parameters, together with ranges of admissible values for each parameters, and a set of excluded parameter values. The characters in a character type share many properties, e.g. they all have the same degree.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"Since \"types\" already have a very specific meaning in Julia (and other programming languages), we instead sometimes refer to character types as \"generic characters\". In particular the Julia types we use to represent character types are called AbstractGenericCharacter, GenericCharacter and SimpleGenericCharacter.","category":"page"},{"location":"characters/#Properties","page":"Character types","title":"Properties","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"number_of_character_types\nnumber_of_characters(char::GenericCharacter)\ndegree(chi::AbstractGenericCharacter)\nparams(chi::GenericCharacter)\nprintinfochar","category":"page"},{"location":"characters/#GenericCharacterTables.number_of_character_types","page":"Character types","title":"GenericCharacterTables.number_of_character_types","text":"number_of_character_types(t::Table)\n\nReturn the number of character types of table t. This can also be obtained via length(t).\n\nExamples\n\n```jldoctest julia> g=genchartab(\"GL2\");\n\njulia> numberofcharacter_types(g) 4\n\n\n\n\n\n","category":"function"},{"location":"characters/#GenericCharacterTables.number_of_characters-Tuple{GenericCharacterTables.GenericCharacter}","page":"Character types","title":"GenericCharacterTables.number_of_characters","text":"number_of_characters(char::GenericCharacter)\n\nReturn the number of characters in the generic character char.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> number_of_characters(g[1])\nq - 1\n\n\n\n\n\n\n","category":"method"},{"location":"characters/#AbstractAlgebra.degree-Tuple{GenericCharacterTables.AbstractGenericCharacter}","page":"Character types","title":"AbstractAlgebra.degree","text":"degree(char::AbstractGenericCharacter)\n\nReturn the character degree of the characters in char.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> degree(g[3])\nq + 1\n\n\n\n\n\n\n","category":"method"},{"location":"characters/#GenericCharacterTables.params-Tuple{GenericCharacterTables.GenericCharacter}","page":"Character types","title":"GenericCharacterTables.params","text":"params(char::AbstractGenericCharacter)\n\nReturn the parameters of the character type char. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> params(g[3])\nk ‚àà {1,‚Ä¶, q - 1}, l ‚àà {1,‚Ä¶, q - 1} except -l + k ‚àà (q - 1)‚Ñ§\n\n\n\n\n\n","category":"method"},{"location":"characters/#GenericCharacterTables.printinfochar","page":"Character types","title":"GenericCharacterTables.printinfochar","text":"printinfochar([io::IO], t::Table, char::Union{Int64, Nothing}=nothing)\n\nPrint to io (or to the default output stream stdout if io is not given) the infolists of the character type char of the table t.\n\nLeaving char unspecified will print the infolists of all character types.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> printinfochar(g)\n1\tAny[Any[1, 0], Any[\"A_1\", [2]]]\n2\tAny[Any[1, 1], Any[\"A_1\", [1, 1]]]\n3\tAny[Any[2, 0], Any[\"A_0\", [1]]]\n4\tAny[Any[3, 0], Any[\"A_0\", [1]]]\n\n\n\n\n\n\n","category":"function"},{"location":"characters/#Iteration","page":"Character types","title":"Iteration","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"Tables implement Julia's iteration interface to iterate over values stored in character types. For a character type ct,","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"length(ct) returns the number of values in the character type (which is equal to the number  of class types s in the table), and\nct[i] returns the ith value of the character type.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"julia> g=genchartab(\"GL2\");\n\njulia> ct = g[3]\nGeneric character of GL2\n  with parameters\n    k ‚àà {1,‚Ä¶, q - 1}, l ‚àà {1,‚Ä¶, q - 1} except -l + k ‚àà (q - 1)‚Ñ§\n  of degree q + 1\n  with values\n    (q + 1)*exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n    exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n    exp(2œÄùëñ((i*l + j*k)//(q - 1))) + exp(2œÄùëñ((i*k + j*l)//(q - 1)))\n    0\n\njulia> collect(ct)\n4-element Vector{GenericCharacterTables.GenericCyclo}:\n (q + 1)*exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n exp(2œÄùëñ((i*l + j*k)//(q - 1))) + exp(2œÄùëñ((i*k + j*l)//(q - 1)))\n 0","category":"page"},{"location":"characters/#Constructing-new-character-types","page":"Character types","title":"Constructing new character types","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"The immediate way to obtain a character type object is to get it from a  table T via indexing, i.e., as T[i] for some index i.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"In addition, there are a few ways to construct new character types.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"tensor_product(char1::GenericCharacter, char2::GenericCharacter)\ntensor_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T <: PolyRingElem\nlincomb\nomega","category":"page"},{"location":"characters/#Hecke.tensor_product-Tuple{GenericCharacterTables.GenericCharacter, GenericCharacterTables.GenericCharacter}","page":"Character types","title":"Hecke.tensor_product","text":"tensor_product(char1::GenericCharacter, char2::GenericCharacter)\n\nReturn the tensor product of the character types char1 and char2. This can also be obtained via char1 * char2.\n\nExamples\n\njulia> g = genchartab(\"GL2\");\n\njulia> tensor_product(g[1], g[2])\nGeneric character of GL2\n  with parameters\n    kt1 ‚àà {1,‚Ä¶, q - 1}, kt2 ‚àà {1,‚Ä¶, q - 1}\n  of degree q\n  with values\n    q*exp(2œÄùëñ((2*i*kt1 + 2*i*kt2)//(q - 1)))\n    0\n    exp(2œÄùëñ((i*kt1 + i*kt2 + j*kt1 + j*kt2)//(q - 1)))\n    (-1)*exp(2œÄùëñ((i*kt1 + i*kt2)//(q - 1)))\n\n\n\n\n\n","category":"method"},{"location":"characters/#Hecke.tensor_product-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleGenericCharacter{T}, GenericCharacterTables.SimpleGenericCharacter{T}}} where T<:AbstractAlgebra.PolyRingElem","page":"Character types","title":"Hecke.tensor_product","text":"tensor_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T<:PolyRingElem\n\nReturn the tensor product of the character types char1 and char2. This can also be obtained via char1 * char2.\n\nExamples\n\njulia> g = greenfuntab(\"GL3\");\n\njulia> tensor_product(g[1],g[2])\nGeneric character of GL3\n  of degree -q^6 - 2*q^5 - 2*q^4 + 2*q^2 + 2*q + 1\n  with values\n    -q^6 - 2*q^5 - 2*q^4 + 2*q^2 + 2*q + 1\n    2*q + 1\n    1\n\n\n\n\n\n","category":"method"},{"location":"characters/#GenericCharacterTables.lincomb","page":"Character types","title":"GenericCharacterTables.lincomb","text":"lincomb(coeffs::Vector{Int64}, chars::Vector{<:GenericCharacter})\n\nReturn the linear combination of the character types chars with coefficients coeffs.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> lincomb([5,1],[g[1],g[2]])\nGeneric character of GL2\n  with parameters\n    kl1 ‚àà {1,‚Ä¶, q - 1}, kl2 ‚àà {1,‚Ä¶, q - 1}\n  of degree q + 5\n  with values\n    (5)*exp(2œÄùëñ((2*i*kl1)//(q - 1))) + q*exp(2œÄùëñ((2*i*kl2)//(q - 1)))\n    (5)*exp(2œÄùëñ((2*i*kl1)//(q - 1)))\n    exp(2œÄùëñ((i*kl2 + j*kl2)//(q - 1))) + (5)*exp(2œÄùëñ((i*kl1 + j*kl1)//(q - 1)))\n    (-1)*exp(2œÄùëñ((i*kl2)//(q - 1))) + (5)*exp(2œÄùëñ((i*kl1)//(q - 1)))\n\n\n\n\n\nlincomb(coeffs::Vector{Int64}, chars::Vector{SimpleGenericCharacter{T}}) where T <: NfPoly\n\nReturn the linear combination of the character types chars with coefficients coeffs.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> lincomb([5,1],[g[1],g[2]])\nGeneric character of GL3\n  of degree 4*q^3 + 10*q^2 + 10*q + 6\n  with values\n    4*q^3 + 10*q^2 + 10*q + 6\n    10*q + 6\n    6\n\n\n\n\n\n","category":"function"},{"location":"characters/#GenericCharacterTables.omega","page":"Character types","title":"GenericCharacterTables.omega","text":"omega(char::GenericCharacter)\n\nReturn the (generic) central character of the character type char.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> omega(g[1])\nGeneric character of GL2\n  with parameters\n    k ‚àà {1,‚Ä¶, q - 1}\n  of degree 1\n  with values\n    exp(2œÄùëñ((2*i*k)//(q - 1)))\n    (q^2 - 1)*exp(2œÄùëñ((2*i*k)//(q - 1)))\n    (q^2 + q)*exp(2œÄùëñ((i*k + j*k)//(q - 1)))\n    (q^2 - q)*exp(2œÄùëñ((i*k)//(q - 1)))\n\n\n\n\n\n\nomega(char::SimpleGenericCharacter{T}) where T <: NfPoly\n\nReturn the (generic) central character of the character type char.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> omega(g[1])\nGeneric character of GL3\n  of degree 1\n  with values\n    1\n    2*q^2 - q - 1\n    q^3 - 2*q^2 + q\n\n\n\n\n\n","category":"function"},{"location":"characters/#Norms-and-scalar-products","page":"Character types","title":"Norms and scalar products","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"GenericCharacterTables allows you to compute norms and scalar products of character types. The results are correct for all possible combinations of parameters except possibly for those where the additionally returned exceptions apply. Those consist of multivariate polynomials with coefficients in a rational function field and are satisfied if the evaluation of this polynomial is an integer.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"norm(char::GenericCharacter)\nnorm(char::SimpleGenericCharacter{T}) where T <: NfPoly\nscalar_product(char1::GenericCharacter, char2::GenericCharacter)\nscalar_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T <: NfPoly","category":"page"},{"location":"characters/#LinearAlgebra.norm-Tuple{GenericCharacterTables.GenericCharacter}","page":"Character types","title":"LinearAlgebra.norm","text":"norm(char::GenericCharacter)\n\nReturn the norm of the character type char.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> norm(g[1])\n1\n\n\n\n\n\n","category":"method"},{"location":"characters/#LinearAlgebra.norm-Union{Tuple{GenericCharacterTables.SimpleGenericCharacter{T}}, Tuple{T}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Character types","title":"LinearAlgebra.norm","text":"norm(char::SimpleGenericCharacter{T}) where T <: NfPoly\n\nReturn the norm of the character type char.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> norm(g[1])\n6//(q^3 - 3*q^2 + 3*q - 1)\n\n\n\n\n\n","category":"method"},{"location":"characters/#Oscar.scalar_product-Tuple{GenericCharacterTables.GenericCharacter, GenericCharacterTables.GenericCharacter}","page":"Character types","title":"Oscar.scalar_product","text":"scalar_product(char1::GenericCharacter, char2::GenericCharacter)\n\nReturn the scalar product between the character types char1 and char2.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> scalar_product(g[3],g[2])\n0\nWith exceptions:\n  l1 + k1 - 2*k2 ‚àà (q - 1)‚Ñ§\n  l1 - k2 ‚àà (q - 1)‚Ñ§\n  k1 - k2 ‚àà (q - 1)‚Ñ§\n\n\n\n\n\n","category":"method"},{"location":"characters/#Oscar.scalar_product-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleGenericCharacter{T}, GenericCharacterTables.SimpleGenericCharacter{T}}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Character types","title":"Oscar.scalar_product","text":"scalar_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T <: NfPoly\n\nReturn the scalar product between the character types char1 and char2.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> scalar_product(g[1],g[2])\n0\n\n\n\n\n\n","category":"method"},{"location":"modify/","page":"Specializing parameters","title":"Specializing parameters","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"modify/#Specializing-parameters","page":"Specializing parameters","title":"Specializing parameters","text":"","category":"section"},{"location":"modify/","page":"Specializing parameters","title":"Specializing parameters","text":"Sometimes one likes to specify some of the free variables in the tables to simplify the often very complicated values a bit.","category":"page"},{"location":"modify/","page":"Specializing parameters","title":"Specializing parameters","text":"setcongruence\nspecialize\nspecclassparam!","category":"page"},{"location":"modify/#GenericCharacterTables.setcongruence","page":"Specializing parameters","title":"GenericCharacterTables.setcongruence","text":"setcongruence(x::CharTable, congruence::Tuple{ZZRingElem, ZZRingElem})\n\nReturn a new generic character table based on x where the main parameter is additionally assumed to be congruent to congruence[1] modulo congruence[2]. So the entries of x can potentially be simplified further.\n\n\n\n\n\nsetcongruence(x::CharTable; remainder::Union{Int, ZZRingElem}, modulus::Union{Int, ZZRingElem})\n\nReturn a new generic character table based on x where the main parameter is additionally assumed to be congruent to remainder modulo modulus. So the entries of x can potentially be simplified further. All existing congruences in x will be preserved. This function is usefull for decomposing tensor products.\n\nExamples\n\njulia> g=genchartab(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\njulia> setcongruence(g; remainder=0, modulus=2)\nGeneric character table GL2*\n  of order q^4 - q^3 - q^2 + q\n  restricted to q congruent to 0 modulo 2\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\n\n\n\n\n","category":"function"},{"location":"modify/#GenericCharacterTables.specialize","page":"Specializing parameters","title":"GenericCharacterTables.specialize","text":"specialize(char::GenericCharacter, var::UPoly, expr::RingElement)\n\nReturn the generic character where the parameter var is replaced with expr in char.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> g[1]\nGeneric character of GL2\n  with parameters\n    k ‚àà {1,‚Ä¶, q - 1}\n  of degree 1\n  with values\n    exp(2œÄùëñ((2*i*k)//(q - 1)))\n    exp(2œÄùëñ((2*i*k)//(q - 1)))\n    exp(2œÄùëñ((i*k + j*k)//(q - 1)))\n    exp(2œÄùëñ((i*k)//(q - 1)))\n\njulia> q,(i,j,l,k) = params(g);\n\njulia> specialize(g[1], i, q)\nGeneric character of GL2\n  with parameters\n    k ‚àà {1,‚Ä¶, q - 1}, substitutions: i = q\n  of degree 1\n  with values\n    exp(2œÄùëñ((2*k)//(q - 1)))\n    exp(2œÄùëñ((2*k)//(q - 1)))\n    exp(2œÄùëñ((j*k + k)//(q - 1)))\n    exp(2œÄùëñ(k//(q - 1)))\n\n\n\n\n\n\n","category":"function"},{"location":"modify/#GenericCharacterTables.specclassparam!","page":"Specializing parameters","title":"GenericCharacterTables.specclassparam!","text":"specclassparam!(t::CharTable, class::Int64, var::UPoly, expr::RingElement)\n\nReplace the parameter var with expr in the class type class.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> [c[1] for c in g]\n4-element Vector{GenericCharacterTables.GenericCyclo}:\n exp(2œÄùëñ((2*i*k)//(q - 1)))\n q*exp(2œÄùëñ((2*i*k)//(q - 1)))\n (q + 1)*exp(2œÄùëñ((i*l + i*k)//(q - 1)))\n (q - 1)*exp(2œÄùëñ((i*k)//(q - 1)))\n\njulia> q,(i,j,l,k) = params(g);\n\njulia> specclassparam!(g, 1, k, 3)\n\njulia> [c[1] for c in g]\n4-element Vector{GenericCharacterTables.GenericCyclo}:\n exp(2œÄùëñ((6*i)//(q - 1)))\n q*exp(2œÄùëñ((6*i)//(q - 1)))\n (q + 1)*exp(2œÄùëñ((i*l + 3*i)//(q - 1)))\n (q - 1)*exp(2œÄùëñ((3*i)//(q - 1)))\n\n\n\n\n\n","category":"function"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"classes/#Conjugacy-class-types","page":"Conjugacy class types","title":"Conjugacy class types","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"A class type is a family of conjugacy classes which are indexed by a set of parameters, together with ranges of admissible values for each parameters, and a set of excluded parameter values.","category":"page"},{"location":"classes/#Properties","page":"Conjugacy class types","title":"Properties","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"number_of_conjugacy_class_types\nnumber_of_conjugacy_classes(t::Table)\nnumber_of_conjugacy_classes(t::CharTable, class::Int64)\ncentralizer_order\nprintclassparam\nprintinfoclass","category":"page"},{"location":"classes/#GenericCharacterTables.number_of_conjugacy_class_types","page":"Conjugacy class types","title":"GenericCharacterTables.number_of_conjugacy_class_types","text":"number_of_conjugacy_class_types(t::Table)\n\nReturn the number of conjugacy class types of table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> number_of_conjugacy_class_types(g)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"classes/#Oscar.number_of_conjugacy_classes-Tuple{GenericCharacterTables.Table}","page":"Conjugacy class types","title":"Oscar.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(t::Table)\n\nReturn the number of conjugacy classes of table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> number_of_conjugacy_classes(g)\nq^2 - 1\n\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.number_of_conjugacy_classes-Tuple{GenericCharacterTables.CharTable, Int64}","page":"Conjugacy class types","title":"Oscar.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(t::Table, class::Int64)\n\nReturn the number of conjugacy classes in the class type class of the table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> number_of_conjugacy_classes(g, 1)\nq - 1\n\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.centralizer_order","page":"Conjugacy class types","title":"GenericCharacterTables.centralizer_order","text":"centralizer_order(t::Table, class::Int64)\n\nReturn the order of the centralizer of the class type class of the table t.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> centralizer_order(g, 1)\nq^4 - q^3 - q^2 + q\n\n\n\n\n\n\n","category":"function"},{"location":"classes/#GenericCharacterTables.printclassparam","page":"Conjugacy class types","title":"GenericCharacterTables.printclassparam","text":"printclassparam([io::IO], t::CharTable, class::Union{Int64, Nothing}=nothing)\n\nPrint to io (or to the default output stream stdout if io is not given) the parameters of the class type class of the table t.\n\nThis includes the parameter names, ranges and exceptions. Leaving class unspecified will print the parameters of all character types.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> printclassparam(g)\n1\ti ‚àà {1,‚Ä¶, q - 1}\n2\ti ‚àà {1,‚Ä¶, q - 1}\n3\ti ‚àà {1,‚Ä¶, q - 1}, j ‚àà {1,‚Ä¶, q - 1} except i - j ‚àà (q - 1)‚Ñ§\n4\ti ‚àà {1,‚Ä¶, q^2 - 1} except i ‚àà (q + 1)‚Ñ§\n\n\n\n\n\n","category":"function"},{"location":"classes/#GenericCharacterTables.printinfoclass","page":"Conjugacy class types","title":"GenericCharacterTables.printinfoclass","text":"printinfoclass([io::IO], t::Table, class::Union{Int64, Nothing}=nothing)\n\nPrint to io (or to the default output stream stdout if io is not given) the infolists of the class type class of the table t.\n\nLeaving class unspecified will print the infolists of all class types.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> printinfoclass(g)\n1\tAny[Any[1, 0], Any[\"A_1\", [1, 1]]]\n2\tAny[Any[1, 1], Any[\"A_1\", [2]]]\n3\tAny[Any[2, 0], Any[\"A_0\", [1]]]\n4\tAny[Any[3, 0], Any[\"A_0\", [1]]]\n\n\n\n\n\n\n","category":"function"},{"location":"classes/#Norms-and-scalar-products","page":"Conjugacy class types","title":"Norms and scalar products","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"GenericCharacterTables allows you to compute norms and scalar products of class types. The results are correct for all possible combinations of parameters except possibly for those where the additionally returned exceptions apply. Those consist of multivariate polynomials with coefficients in a rational function field and are satisfied if the evaluation of this polynomial is an integer.","category":"page"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"norm(t::CharTable, class::Int64)\nnorm(t::SimpleCharTable{T}, class::Int64) where T <: NfPoly\nscalar_product(t::CharTable, class1::Int64, class2::Int64)\nscalar_product(t::SimpleCharTable{T}, class1::Int64, class2::Int64) where T <: NfPoly\nclass_multiplication_coefficient(t::CharTable, class1::Int64, class2::Int64, class3::Int64)\nclass_multiplication_coefficient(t::SimpleCharTable{T}, class1::Int64, class2::Int64, class3::Int64) where T <: NfPoly","category":"page"},{"location":"classes/#LinearAlgebra.norm-Tuple{GenericCharacterTables.CharTable, Int64}","page":"Conjugacy class types","title":"LinearAlgebra.norm","text":"norm(t::CharTable, class::Int64)\n\nReturn the (generic) norm of the class type class.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> norm(g,2)\n1\n\n\n\n\n\n","category":"method"},{"location":"classes/#LinearAlgebra.norm-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleCharTable{T}, Int64}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Conjugacy class types","title":"LinearAlgebra.norm","text":"norm(t::SimpleCharTable{T}, class::Int64) where T <: NfPoly\n\nReturn the (generic) norm of the class type class.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> norm(g,2)\n(5*q^2 + 2*q + 3)//(q^5 - 2*q^4 + q^3)\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.scalar_product-Tuple{GenericCharacterTables.CharTable, Int64, Int64}","page":"Conjugacy class types","title":"Oscar.scalar_product","text":"scalar_product(t::CharTable, class1::Int64, class2::Int64)\n\nReturn the (generic) scalar product between the class types class1 and class2.\n\nExamples\n\njulia> g=genchartab(\"GL2\");\n\njulia> scalar_product(g,3,2)\n0\nWith exceptions:\n  i1 + j1 - 2*i2 ‚àà (q - 1)‚Ñ§\n  i1 - i2 ‚àà (q - 1)‚Ñ§\n  j1 - i2 ‚àà (q - 1)‚Ñ§\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.scalar_product-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleCharTable{T}, Int64, Int64}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Conjugacy class types","title":"Oscar.scalar_product","text":"scalar_product(t::SimpleCharTable{T}, class1::Int64, class2::Int64) where T <: NfPoly\n\nReturn the (generic) scalar product between the class types class1 and class2.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> scalar_product(g,2,2)\n(5*q^2 + 2*q + 3)//(q^5 - 2*q^4 + q^3)\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.class_multiplication_coefficient-Tuple{GenericCharacterTables.CharTable, Int64, Int64, Int64}","page":"Conjugacy class types","title":"Oscar.class_multiplication_coefficient","text":"class_multiplication_coefficient(t::CharTable, class1::Int64, class2::Int64, class3::Int64)\n\nReturn the (generic) class multiplication coefficient of the class types class1, class2 and class3 of the table t.\n\nExamples\n\njulia> g=genchartab(\"SL2.0\");\n\njulia> class_multiplication_coefficient(g,2,2,4)\nq + 1\nWith exceptions:\n  a3 ‚àà (q + 1)‚Ñ§\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.class_multiplication_coefficient-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleCharTable{T}, Int64, Int64, Int64}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Conjugacy class types","title":"Oscar.class_multiplication_coefficient","text":"class_multiplication_coefficient(t::SimpleCharTable{T}, class1::Int64, class2::Int64, class3::Int64) where T <: NfPoly\n\nReturn the (generic) class multiplication coefficient of the class types class1, class2 and class3 of the table t.\n\nExamples\n\njulia> g=greenfuntab(\"GL3\");\n\njulia> class_multiplication_coefficient(g,1,2,3)\n(q + 3)//(q^5 - 2*q^4 + q^3)\n\n\n\n\n\n","category":"method"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"#GenericCharacterTables.jl","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"","category":"section"},{"location":"#About","page":"GenericCharacterTables.jl","title":"About","text":"","category":"section"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"GenericCharacterTables is a library for working with generic character tables. It is based on CHEVIE and aims to provide all its features originally implemented in Maple. It is written in¬†Julia and depends on Nemo and therefore on AbstractAlgebra.","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"For the mathematical background, consider that there are many interesting families of finite groups. For example, the matrix groups mathrmGL_n(mathbbF_q) or mathrmSL_n(mathbbF_q), for n1 and q a prime power. These groups have many properties in common. It turns out that for a fixed rank (say n=2) it is possible to parametrize the conjugacy classes and irreducible characters of these group in terms of q, and to write this down into a so-called generic character table. This was first done by Schur for mathrmSL_2(mathbbF_q).","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"This package provides code to interact with such generic character tables, and also includes many such tables. The code in this package is based on Maple code included in the CHEVIE project.","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"For more details about the mathematical background, see [GHLMP96].","category":"page"},{"location":"cyclo/","page":"Generic cyclotomics","title":"Generic cyclotomics","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"cyclo/#Generic-cyclotomics","page":"Generic cyclotomics","title":"Generic cyclotomics","text":"","category":"section"},{"location":"cyclo/","page":"Generic cyclotomics","title":"Generic cyclotomics","text":"TODO: this file should contain information about generic cyclotomics: what these are, how to work with them; what is and isn't implemented.","category":"page"}]
}

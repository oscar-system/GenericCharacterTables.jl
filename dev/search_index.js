var documenterSearchIndex = {"docs":
[{"location":"tables/","page":"Tables","title":"Tables","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"tables/#Tables","page":"Tables","title":"Tables","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"This section describes how to instantiate generic character tables and tables of Green functions, as well as various functions for accessing properties of these tables.","category":"page"},{"location":"tables/#Loading-tables","page":"Tables","title":"Loading tables","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"Before doing anything you need to load a table first. GenericCharacterTables comes with a variety of precomputed tables.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"generic_character_table","category":"page"},{"location":"tables/#GenericCharacterTables.generic_character_table","page":"Tables","title":"GenericCharacterTables.generic_character_table","text":"generic_character_table(x::String)\n\nReturn the generic character table with name x.\n\nOmitting x will return the names of all importable character tables.\n\nExamples\n\njulia> g = generic_character_table(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\n\n\n\n\n","category":"function"},{"location":"tables/","page":"Tables","title":"Tables","text":"GenericCharacterTables also provides some tables of Green functions. They can be loaded similarly.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"green_function_table","category":"page"},{"location":"tables/#GenericCharacterTables.green_function_table","page":"Tables","title":"GenericCharacterTables.green_function_table","text":"green_function_table(x::String)\n\nReturn the greenfunction table with name x.\n\nOmitting x will return the names of all importable greenfunctions.\n\nExamples\n\njulia> g = green_function_table(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 2 irreducible character types\n  with 2 class types\n  without parameters\n\n\n\n\n\n","category":"function"},{"location":"tables/#Properties","page":"Tables","title":"Properties","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"info(t::Table)\nnumber_of_characters(t::Table)\nnumber_of_parameters\nparameters\norder(t::Table)","category":"page"},{"location":"tables/#GenericCharacterTables.info-Tuple{GenericCharacterTables.Table}","page":"Tables","title":"GenericCharacterTables.info","text":"info(t::Table)\n\nReturn the metadata of t in LaTeX format. This usually includes the time the table was first computed.\n\n\n\n\n\n","category":"method"},{"location":"tables/#GenericCharacterTables.number_of_characters-Tuple{GenericCharacterTables.Table}","page":"Tables","title":"GenericCharacterTables.number_of_characters","text":"number_of_characters(t::Table)\n\nReturn the number of irreducible characters of table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_characters(g)\nq^2 - 1\n\n\n\n\n\n\n","category":"method"},{"location":"tables/#GenericCharacterTables.number_of_parameters","page":"Tables","title":"GenericCharacterTables.number_of_parameters","text":"number_of_parameters(t::CharTable)\n\nReturn the number of class and character parameters of the table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_parameters(g)\n4\n\n\n\n\n\n\nnumber_of_parameters(t::SimpleCharTable)\n\nReturn the number of class and character parameters of the table t.\n\nExamples\n\njulia> g=green_function_table(\"GL2\");\n\njulia> number_of_parameters(g)\n0\n\n\n\n\n\n\n","category":"function"},{"location":"tables/#GenericCharacterTables.parameters","page":"Tables","title":"GenericCharacterTables.parameters","text":"parameters(t::CharTable)\n\nReturn all parameters the table t depends on.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(g)\n(q, (i, j, l, k))\n\n\n\n\n\n\nparameters(t::SimpleCharTable)\n\nReturn all parameters the table t depends on.\n\nExamples\n\njulia> g=green_function_table(\"GL2\");\n\njulia> parameters(g)\n(q, ())\n\n\n\n\n\n\nparameters(class::GenericConjugacyClass)\n\nReturn the parameters of the conjugacy class type class. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(conjugacy_class_type(g, 3))\ni ∈ {1,…, q - 1}, j ∈ {1,…, q - 1} except i - j ∈ (q - 1)ℤ\n\n\n\n\n\nparameters(class::SimpleGenericConjugacyClass)\n\nReturn the parameters of the conjugacy class type class. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"uniGL2\");\n\njulia> parameters(conjugacy_class_type(g, 1))\n\n\n\n\n\n\nparameters(t::Table, class::Int64)\n\nReturn the parameters of the class type class of the table t. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(g, 3)\ni ∈ {1,…, q - 1}, j ∈ {1,…, q - 1} except i - j ∈ (q - 1)ℤ\n\n\n\n\n\n\nparameters(char::AbstractGenericCharacter)\n\nReturn the parameters of the character type char. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(g[3])\nk ∈ {1,…, q - 1}, l ∈ {1,…, q - 1} except -l + k ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"function"},{"location":"tables/#AbstractAlgebra.order-Tuple{GenericCharacterTables.Table}","page":"Tables","title":"AbstractAlgebra.order","text":"order(t::Table)\n\nReturn the order of the table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> order(g)\nq^4 - q^3 - q^2 + q\n\n\n\n\n\n","category":"method"},{"location":"tables/#Iteration","page":"Tables","title":"Iteration","text":"","category":"section"},{"location":"tables/","page":"Tables","title":"Tables","text":"Tables implement Julia's iteration interface to iterate over the irreducible character types stored in the table. For a table T,","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"length(T) returns the number of character types in the table,\nT[i] returns the ith character type.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"For example we can use this to compute the order of the underlying group type. (Of course this can also be checked via order, which retrieves a precomputed value.)","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"julia> g=generic_character_table(\"GL2\");\n\njulia> sum(number_of_characters(c)*degree(c)^2 for c in g)\nq^4 - q^3 - q^2 + q\n\njulia> order(g)\nq^4 - q^3 - q^2 + q","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"Tables also implement a part of Julia's interface for matrices. This can be used to extract \"subtables\" (although these are then of course merely matrices and not generic character table objects).","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"julia> g=generic_character_table(\"GL3\");\n\njulia> g[3:5,2:4]\n3×3 Matrix{GenericCharacterTables.GenericCyclo}:\n 0                               …  q*E(q - 1)^(2*a*n + b*n)\n (q + 1)*E(q - 1)^(a*m + 2*a*n)     E(q - 1)^(2*a*n + b*m) + (q + 1)*E(q - 1)^(a*m + a*n + b*n)\n q*E(q - 1)^(a*m + 2*a*n)           q*E(q - 1)^(2*a*n + b*m) + (q + 1)*E(q - 1)^(a*m + a*n + b*n)\n","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"Here we extracted the values of the character types 3, 4 and 5 on the conjugacy class types 2, 3 and 4. Using colons one can even get all values into a matrix.","category":"page"},{"location":"tables/","page":"Tables","title":"Tables","text":"julia> g=generic_character_table(\"GL2\");\n\njulia> g[:,:]\n4×4 Matrix{GenericCharacterTables.GenericCyclo}:\n E(q - 1)^(2*i*k)              …  E(q - 1)^(i*k)\n q*E(q - 1)^(2*i*k)               -E(q - 1)^(i*k)\n (q + 1)*E(q - 1)^(i*l + i*k)     0\n (q - 1)*E(q - 1)^(i*k)           -E(q^2 - 1)^(q*i*k) - E(q^2 - 1)^(i*k)","category":"page"},{"location":"references/#References","page":"References","title":"References","text":"","category":"section"},{"location":"references/","page":"References","title":"References","text":"W. M. Beynon and N. Spaltenstein. Green functions of finite Chevalley groups of type E_n (n=678). J. Algebra 88, 584–614 (1984).\n\n\n\nB. Chang and R. Ree. The characters of G_2(q). In: Symposia Mathematica, Vol. XIII (Convegno di Gruppi Abeliani & Convegno di Gruppi e                   loro Rappresentazioni, INDAM, Rome, 1972) (Academic Press, London-New York, 1974); pp. 395–413.\n\n\n\nR. W. Carter. Finite groups of Lie type. Pure and Applied Mathematics (New York) (John Wiley & Sons, Inc., New York, 1985); p. xii+544. Conjugacy classes and complex characters, A Wiley-Interscience Publication.\n\n\n\nB. Chang. The conjugate classes of Chevalley groups of type G_2. J. Algebra 9, 190–211 (1968).\n\n\n\nD. I. Deriziotis and G. O. Michler. Character table and blocks of finite simple triality groups ^3D_4(q). Trans. Am. Math. Soc. 303, 39–70 (1987).\n\n\n\nF. Digne and J. Michel. Foncteurs de Lusztig et caractères des groupes linéaires et unitaires sur un corps fini. Journal of Algebra 107, 217–255 (1987).\n\n\n\nH. Enomoto and H. Yamada. The characters of G_2(2^n). Japan. J. Math. (N.S.) 12, 325–377 (1986).\n\n\n\nV. Ennola. On the conjugacy classes of the finite unitary groups. Ann. Acad. Sci. Fenn., Ser. A I 313, 13 (1962).\n\n\n\nV. Ennola. On the characters of the finite unitary groups. Ann. Acad. Sci. Fenn., Ser. A I 323, 35 (1963).\n\n\n\nH. Enomoto. The characters of the finite symplectic group textSp(4q), q=2^f. Osaka J. Math. 9, 75–94 (1972).\n\n\n\nH. Enomoto. The characters of the finite Chevalley group G_2(q)q=3^f. Japan. J. Math. (N.S.) 2, 191–248 (1976).\n\n\n\nG. Frobenius. Ueber Gruppencharaktere. Berl. Ber. 1896, 985–1021 (1896).\n\n\n\nM. Geck, G. Hiß, F. Lübeck, G. Malle and G. Pfeiffer. CHEVIE—a system for computing and processing generic character tables. Appl. Algebra Engrg. Comm. Comput. 7, 175–210 (1996). Computational methods in Lie theory (Essen, 1994).\n\n\n\nM. Geck and G. Pfeiffer. Unipotent characters of the Chevalley groups D_4(q), q odd. Manuscr. Math. 76, 281–304 (1992).\n\n\n\nM. Geck. Irreducible Brauer characters of the 3-dimensional special unitary groups in non-defining                   characteristic. Commun. Algebra 18, 563–584 (1990).\n\n\n\nJ. A. Green. The characters of the finite general linear groups. Trans. Am. Math. Soc. 80, 402–447 (1955).\n\n\n\nR. Hotta and T. A. Springer. A specialization theorem for certain Weyl group representations and an application to the Green                   polynomials of unitary groups. Invent. Math. 41, 113–127 (1977).\n\n\n\nG. Hiß. Zerlegungszahlen endlicher Gruppen vom Lie-Typ in nicht-definierender Charakteristik. (Aachen: Techn. Hochsch. Aachen, Mathematisch-Naturwiss. Fakultät, 1990).\n\n\n\nH. E. Jordan. Group-characters of various types of linear groups. Am. J. Math. 29, 387–405 (1907).\n\n\n\nN. Kawanaka. Generalized Gelfand-Graev representations and Ennola duality. In: Algebraic groups and related topics (Kyoto/Nagoya, 1983), Vol. 6 of Adv. Stud. Pure Math. (North-Holland, Amsterdam, 1985); pp. 175–206.\n\n\n\nA. J. Kempner. Polynomials and their residue systems. Trans. Amer. Math. Soc. 22, 240–266 (1921).\n\n\n\nA. Lascoux and M.-P. Schützenberger. Sur une conjecture de H. O. Foulkes. C. R. Acad. Sci. Paris Sér. A-B 286, A323–A324 (1978).\n\n\n\nL. Lambe and B. Srinivasan. A computation of Green functions for some classical groups. Commun. Algebra 18, 3507–3545 (1990).\n\n\n\nF. Lübeck. Charaktertafeln für die Gruppen textCSp_6(q) mit ungeradem q und textSp_6(q) mit                   geradem q. (Heidelberg: Universität Heidelberg, Naturw.-Math. Gesamtfakultät, 1993).\n\n\n\nJ. Looker. The complex irreducible characters of Sp(6, q), q even. Bull. Aust. Math. Soc. 17, 475–476 (1977).\n\n\n\nR. M. Marcelo and K.-i. Shinoda. Values of the unipotent characters of the Chevalley group of type F_4 at unipotent elements. Tokyo J. Math. 18, 303–340 (1995).\n\n\n\nG. Malle. Die unipotenten Charaktere von ^2F_4(q^2). (The unipotent characters of ^2F_4(q^2)). Commun. Algebra 18, 2361–2381 (1990).\n\n\n\nG. Malle. Green functions for groups of types E_6 and F_4 in characteristic 2. Commun. Algebra 21, 747–798 (1993).\n\n\n\nG. Malle. Generalized Deligne-Lusztig characters. J. Algebra 159, 64–97 (1993).\n\n\n\nThe Computer Algebra System OSCAR: Algorithms and Examples. Vol. 32 of Algorithms and Computation in Mathematics (Springer, 2024).\n\n\n\nW. A. Simpson and J. S. Frame. The character tables for textSL(3q), textSU(3q^2), textPSL(3q), textPSU(3q^2). Can. J. Math. 25, 486–494 (1973).\n\n\n\nI. Schur. Untersuchungen über die Darstellung der endlichen Gruppen durch gebrochene lineare                   Substitutionen. J. Reine Angew. Math. 132, 85–137 (1907).\n\n\n\nK.-i. Shinoda. The conjugacy classes of Chevalley groups of type F_4 over finite fields of characteristic 2. J. Fac. Sci., Univ. Tokyo, Sect. I A 21, 133–159 (1974).\n\n\n\nK.-i. Shinoda. The characters of the finite conformal symplectic group, textCSp(4q). Commun. Algebra 10, 1369–1419 (1982).\n\n\n\nT. Shoji. On the Green polynomials of a Chevalley group of type F_4. Commun. Algebra 10, 505–543 (1982).\n\n\n\nN. Spaltenstein. Classes unipotentes et sous-groupes de Borel. Vol. 946 of Lect. Notes Math. (Springer, Cham, 1982).\n\n\n\nN. Spaltenstein. Caractères unipotents de ^3D_4(mathbbF_q). Comment. Math. Helv. 57, 676–691 (1982).\n\n\n\nB. Srinivasan. The characters of the finite symplectic group textSp(4q). Trans. Am. Math. Soc. 131, 488–525 (1968).\n\n\n\nR. Steinberg. The representations of textGL(3q), textGL(4q), textPGL(3q), and textPGL(4q). Can. J. Math. 3, 225–235 (1951).\n\n\n\nM. Suzuki. On a class of doubly transitive groups. Ann. Math. (2) 75, 105–145 (1962).\n\n\n\nH. N. Ward. On Ree's series of simple groups. Trans. Am. Math. Soc. 121, 62–89 (1966).\n\n\n\n","category":"page"},{"location":"unexported/","page":"Unexported Functions","title":"Unexported Functions","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"unexported/#Unexported-Functions","page":"Unexported Functions","title":"Unexported Functions","text":"","category":"section"},{"location":"unexported/","page":"Unexported Functions","title":"Unexported Functions","text":"These are all functions for internal use only:","category":"page"},{"location":"unexported/","page":"Unexported Functions","title":"Unexported Functions","text":"Modules = [GenericCharacterTables]\nPublic = false","category":"page"},{"location":"unexported/#GenericCharacterTables.CharTable","page":"Unexported Functions","title":"GenericCharacterTables.CharTable","text":"CharTable <: Table\n\nThe type for generic character tables. This is used to model generic character tables containing generic cyclotomic entries.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.CharTable-Tuple{GenericCharacterTables.GenericCharacter}","page":"Unexported Functions","title":"GenericCharacterTables.CharTable","text":"(t::CharTable)(c::GenericCharacter)\n\nReturn c as a generic character of t. This will only work if t is a version of the parent table of c with a more restricted congruence.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.GenericCharacter","page":"Unexported Functions","title":"GenericCharacterTables.GenericCharacter","text":"GenericCharacter <: AbstractGenericCharacter\n\nThe type for generic characters. These are the generic characters used in CharTable.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> g[1]\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}\n  of degree 1\n  with values\n    1: E(q - 1)^(2*i*k)\n    2: E(q - 1)^(2*i*k)\n    3: E(q - 1)^(i*k + j*k)\n    4: E(q - 1)^(i*k)\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericConjugacyClass","page":"Unexported Functions","title":"GenericCharacterTables.GenericConjugacyClass","text":"GenericConjugacyClass <: AbstractGenericConjugacyClass\n\nThe type for generic conjugacy classes. These are the generic conjugacy classes used in CharTable.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericCyclo","page":"Unexported Functions","title":"GenericCharacterTables.GenericCyclo","text":"GenericCyclo <: RingElem\n\nThe type for generic cyclotomic numbers.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S, E = generic_cyclotomic_ring(R);\n\njulia> S(q; exponent=1//(q-1))\nq*E(q - 1)\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericCycloFrac","page":"Unexported Functions","title":"GenericCharacterTables.GenericCycloFrac","text":"GenericCycloFrac\n\nThe type for fractions of generic cyclotomic numbers.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S, E = generic_cyclotomic_ring(R);\n\njulia> a = S(q; exponent=1//(q-1))\nq*E(q - 1)\n\njulia> b = S(q^2; exponent=1//(q^2-1))\nq^2*E(q^2 - 1)\n\njulia> a//b\nq*E(q - 1)//(q^2*E(q^2 - 1))\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.GenericCycloRing","page":"Unexported Functions","title":"GenericCharacterTables.GenericCycloRing","text":"GenericCycloRing <: Ring\n\nThe ring of generic cyclotomic numbers.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S, E = generic_cyclotomic_ring(R)\n(Generic cyclotomic ring over Rational field, Generator of Generic cyclotomic ring over Rational field)\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.Parameter","page":"Unexported Functions","title":"GenericCharacterTables.Parameter","text":"Parameter\n\nA paramter of a generic character or class type unique up to a polynomial modulus. They are used in Parameters.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.ParameterExceptions","page":"Unexported Functions","title":"GenericCharacterTables.ParameterExceptions","text":"ParameterExceptions\n\nA collection of parameter exceptions used in GenericCycloFrac.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.ParameterSubstitution","page":"Unexported Functions","title":"GenericCharacterTables.ParameterSubstitution","text":"ParameterSubstitution\n\nA substitution of paramters used in Parameters. They are generated by for example specclassparam!.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.Parameters","page":"Unexported Functions","title":"GenericCharacterTables.Parameters","text":"Parameters\n\nParameters of generic characters and class types. This is used in GenericCharacter and CharTable and is only of internal use.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.SimpleCharTable","page":"Unexported Functions","title":"GenericCharacterTables.SimpleCharTable","text":"SimpleCharTable{T} <: Table\n\nThe type for simple generic character tables. This is used to model generic character tables containing polynomial entries. The type parameter T is the type of the table entries.\n\nExamples\n\njulia> g=generic_character_table(\"uniGL2\")\nGeneric character table uniGL2\n  of order q^4 - q^3 - q^2 + q\n  with 2 irreducible character types\n  with 4 class types\n  without parameters\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.SimpleGenericCharacter","page":"Unexported Functions","title":"GenericCharacterTables.SimpleGenericCharacter","text":"SimpleGenericCharacter <: AbstractGenericCharacter\n\nThe type for simple generic characters. These are the generic characters used in SimpleCharTable.\n\nExamples\n\njulia> g=generic_character_table(\"uniGL2\")\nGeneric character table uniGL2\n  of order q^4 - q^3 - q^2 + q\n  with 2 irreducible character types\n  with 4 class types\n  without parameters\n\njulia> g[1]\nGeneric character of uniGL2\n  of degree q\n  with values\n    1: q\n    2: 0\n    3: 1\n    4: -1\n\n\n\n\n\n","category":"type"},{"location":"unexported/#GenericCharacterTables.SimpleGenericConjugacyClass","page":"Unexported Functions","title":"GenericCharacterTables.SimpleGenericConjugacyClass","text":"SimpleGenericConjugacyClass <: AbstractGenericConjugacyClass\n\nThe type for simple generic conjugacy classes. These are the generic conjugacy classes used in SimpleCharTable.\n\n\n\n\n\n","category":"type"},{"location":"unexported/#AbstractAlgebra.Generic.normal_form-Tuple{AbstractAlgebra.Generic.UnivPoly{Nemo.ZZRingElem}, Int64}","page":"Unexported Functions","title":"AbstractAlgebra.Generic.normal_form","text":"normal_form(f::ZZUPoly, m::Int64)\n\nReturn a normal form of f modulo m, such that normal_form(f,m) is equal to normal_form(g,m) if and only if f and g are congruent modulo m.\n\nExamples\n\njulia> R=universal_polynomial_ring(ZZ);\n\njulia> x=gen(R, :x);\n\njulia> normal_form(4*x^2,6)\nx^2 + 3*x\n\njulia> normal_form(4*x^2-(x^2+3*x),6)\n0\n\njulia> normal_form(4*x^9+x^7,12)\nx^3 + 4*x\n\njulia> normal_form(4*x^9+x^7-(x^3+4*x),12)\n0\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.iszero-Tuple{GenericCharacterTables.GenericCycloFrac}","page":"Unexported Functions","title":"Base.iszero","text":"iszero(x::GenericCycloFrac; ignore_exceptions::Bool=false)\n\nReturn if x is zero. If ignore_exceptions is true then the exceptions of x will not be considered.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, GenericCharacterTables.AbstractGenericCharacter}","page":"Unexported Functions","title":"Base.show","text":"show(io::IO, c::AbstractGenericCharacter)\n\nDisplay a summary of the generic character c.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> g[3]\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}, l ∈ {1,…, q - 1} except -l + k ∈ (q - 1)ℤ\n  of degree q + 1\n  with values\n    1: (q + 1)*E(q - 1)^(i*l + i*k)\n    2: E(q - 1)^(i*l + i*k)\n    3: E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n    4: 0\n\njulia> [g[3]]\n1-element Vector{GenericCharacterTables.GenericCharacter}:\n Generic character of GL2\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, GenericCharacterTables.AbstractGenericConjugacyClass}","page":"Unexported Functions","title":"Base.show","text":"show(io::IO, c::AbstractGenericConjugacyClass)\n\nDisplay a summary of the generic character c.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> conjugacy_class_type(g, 3)\nGeneric conjugacy class of GL2\n  with parameters\n    i ∈ {1,…, q - 1}, j ∈ {1,…, q - 1} except i - j ∈ (q - 1)ℤ\n  of order q^2 + q\n  with values\n    1: E(q - 1)^(i*k + j*k)\n    2: E(q - 1)^(i*k + j*k)\n    3: E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n    4: 0\n\njulia> [conjugacy_class_type(g, 3)]\n1-element Vector{GenericCharacterTables.GenericConjugacyClass}:\n Generic conjugacy class of GL2\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#Base.show-Tuple{IO, MIME{Symbol(\"text/plain\")}, GenericCharacterTables.Table}","page":"Unexported Functions","title":"Base.show","text":"show(io::IO, t::Table)\n\nDisplay a summary of the generic character table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\njulia> [g]\n1-element Vector{GenericCharacterTables.CharTable}:\n Generic character table GL2\n\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.add_exception!-Tuple{GenericCharacterTables.ParameterExceptions, AbstractAlgebra.Generic.FracFieldElem{AbstractAlgebra.Generic.UnivPoly{Nemo.QQFieldElem}}}","page":"Unexported Functions","title":"GenericCharacterTables.add_exception!","text":"add_exception!(a::ParameterExceptions, exception::UPolyFrac)\n\nInclude exception into a. This also removes all now redundant exceptions from a.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.is_integer-Tuple{AbstractAlgebra.Generic.FracFieldElem{AbstractAlgebra.Generic.UnivPoly{Nemo.QQFieldElem}}}","page":"Unexported Functions","title":"GenericCharacterTables.is_integer","text":"is_integer(x::UPolyFrac)\n\nReturn if x represents an integer.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.is_restriction-Tuple{GenericCharacterTables.ParameterExceptions}","page":"Unexported Functions","title":"GenericCharacterTables.is_restriction","text":"is_restriction(x::ParameterExceptions)\n\nReturn if x actually restricts something.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.merge-Tuple{GenericCharacterTables.ParameterExceptions, GenericCharacterTables.ParameterExceptions}","page":"Unexported Functions","title":"GenericCharacterTables.merge","text":"merge(x::ParameterExceptions, y::ParameterExceptions)\n\nReturn a new collection of parameter exceptions composed of x and y where all redundant exceptions are omitted.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.nesum-Tuple{GenericCharacterTables.GenericCyclo, Int64, Int64, Union{Int64, AbstractAlgebra.Generic.UnivPoly{Nemo.QQFieldElem}}}","page":"Unexported Functions","title":"GenericCharacterTables.nesum","text":"nesum(a::GenericCyclo, var::Int64, lower::Int64, upper::Union{Int64,UPoly})\n\nReturn the sum of a, from var=lower to upper as GenericCycloFrac using the closed formular for geometric sums. If this is not possible an exception will be thrown.\n\nExamples\n\njulia> R = universal_polynomial_ring(QQ; cached=false);\n\njulia> q = gen(R, \"q\");\n\njulia> S, E = generic_cyclotomic_ring(R);\n\njulia> i, = gens(R, [\"i\"]);\n\njulia> a = S(Dict(1//(q-1)*i => R(1)))\nE(q - 1)^i\n\njulia> GenericCharacterTables.nesum(a, i, 1, q-1)\n0\nWith exceptions:\n  1 ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.shift_char_parameters-Tuple{GenericCharacterTables.CharTable, Union{GenericCharacterTables.GenericCyclo, GenericCharacterTables.GenericCycloFrac, GenericCharacterTables.Parameters}, Int64}","page":"Unexported Functions","title":"GenericCharacterTables.shift_char_parameters","text":"shift_char_parameters(t::CharTable, a::Union{Parameters,GenericCyclo,GenericCycloFrac}, steps::Int64)\n\nReplace all character parameters of t in a by their counterparts suffixed with steps.\n\nThis is done by shifting them steps*number_of_parameters(t) steps further in t.argumentring.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.shift_class_parameters-Tuple{GenericCharacterTables.CharTable, Union{GenericCharacterTables.GenericCyclo, GenericCharacterTables.GenericCycloFrac, GenericCharacterTables.Parameters}, Int64}","page":"Unexported Functions","title":"GenericCharacterTables.shift_class_parameters","text":"shift_class_parameters(t::CharTable, a::Union{Parameters,GenericCyclo,GenericCycloFrac}, steps::Int64)\n\nReplace all class parameters of t in a by their counterparts suffixed with steps.\n\nThis is done by shifting them steps*number_of_parameters(t) steps further in t.argumentring.\n\n\n\n\n\n","category":"method"},{"location":"unexported/#GenericCharacterTables.shrink-Tuple{GenericCharacterTables.GenericCycloFrac}","page":"Unexported Functions","title":"GenericCharacterTables.shrink","text":"shrink(a::GenericCycloFrac{<:NfPoly})\n\nRemove exceptions from a that follow from the others. And try to simplify the representation of a.\n\n\n\n\n\n","category":"method"},{"location":"book/","page":"An extended example","title":"An extended example","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"book/#An-extended-example","page":"An extended example","title":"An extended example","text":"","category":"section"},{"location":"book/","page":"An extended example","title":"An extended example","text":"The following is based on an example in [OSCAR], which in turn is based on Section 5.3 of [GHLMP96]. To fully understand what is going on we strongly recommend to read the latter source concurrently with the present text.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"To start we load the generic character table for mathrmSL_3(q) with qnotequiv 1pmod 3. To learn about the origin of the table, we could enter print(info(T)).","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> T = generic_character_table(\"SL3.n1\")\nGeneric character table SL3.n1\n  of order q^8 - q^6 - q^5 + q^3\n  with 8 irreducible character types\n  with 8 class types\n  with parameters (a, b, m, n)","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"As we can see this table has four parameters in addition to q. The entries of the table are “generalized cyclotomics”, that is, linear combinations over mathbbQ(q) of symbolic “roots of unity” depending on the parameters listed above.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> T[4,4]\n(q + 1)*E(q - 1)^(a*n) + E(q - 1)^(-2*a*n)","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Denoting row 4 of the table by chi_4, we note that is not a single character, but a character type, describing a whole family of characters.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> χ₄ = T[4]\nGeneric character of SL3.n1\n  with parameters\n    n ∈ {1,…, q - 1} except n ∈ (q - 1)ℤ\n  of degree q^2 + q + 1\n  with values\n    1: q^2 + q + 1\n    2: q + 1\n    3: 1\n    4: (q + 1)*E(q - 1)^(a*n) + E(q - 1)^(-2*a*n)\n    5: E(q - 1)^(a*n) + E(q - 1)^(-2*a*n)\n    6: E(q - 1)^(a*n) + E(q - 1)^(b*n) + E(q - 1)^(-a*n - b*n)\n    7: E(q - 1)^(a*n)\n    8: 0","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"With these generic characters, we can compute norms, scalar products, and more. For this demonstration we tensor the second character type chi_2 with itself.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> h = T[2] * T[2]\nGeneric character of SL3.n1\n  of degree q^4 + 2*q^3 + q^2\n  with values\n    1: q^4 + 2*q^3 + q^2\n    2: q^2\n    3: 0\n    4: q^2 + 2*q + 1\n    5: 1\n    6: 4\n    7: 0\n    8: 1","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"We may now attempt to decompose this character type h by computing its scalar product with the irreducible character types. This returns a “generic” scalar product, plus a (possibly empty) list of parameter exceptions for which the general result may not hold. For example:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> scalar_product(T[4], h)\n0\nWith exceptions:\n  2*n1 ∈ (q - 1)ℤ","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"This scalar product is 0 except when q-1 divides 2n_1, where n_1 indicates the value of the parameter n for the first factor in the scalar product (i.e. the character type chi_4). For a “generic decomposition” we need to compute all the scalar products and exceptions.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> for i in 1:8 println(\"<$i, h> = \", scalar_product(T[i], h)) end\n<1, h> = 1\n<2, h> = 2\n<3, h> = 2\n<4, h> = 0\nWith exceptions:\n  2*n1 ∈ (q - 1)ℤ\n<5, h> = 0\nWith exceptions:\n  2*n1 ∈ (q - 1)ℤ\n<6, h> = 0\nWith exceptions:\n  2*m1 - n1 ∈ (q - 1)ℤ\n  m1 - 2*n1 ∈ (q - 1)ℤ\n  m1 + n1 ∈ (q - 1)ℤ\n  m1 ∈ (q - 1)ℤ\n  m1 - n1 ∈ (q - 1)ℤ\n  n1 ∈ (q - 1)ℤ\n<7, h> = 0\nWith exceptions:\n  n1 ∈ (q - 1)ℤ\n<8, h> = 0\nWith exceptions:\n  q*n1 ∈ (q^2 + q + 1)ℤ\n  n1 ∈ (q^2 + q + 1)ℤ\n  q*n1 + n1 ∈ (q^2 + q + 1)ℤ","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"This suggest a decomposition of chi_2otimeschi_2 into chi_1+2chi_2+2chi_3 “in general”. But comparing the respective degrees, we notice a discrepancy:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> degree(linear_combination([1,2,2],[T[1],T[2],T[3]]))\n2*q^3 + 2*q^2 + 2*q + 1\n\njulia> degree(h)\nq^4 + 2*q^3 + q^2","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"To resolve this, we need to work through the exceptions. Recall that earlier we saw that langlechi_4chi_2^2rangle=0 except when q-1 divides 2n_1, where n_1 was the value of the parameter n used in chi_4. Further restrictions apply to n:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> parameters(T[4])\nn ∈ {1,…, q - 1} except n ∈ (q - 1)ℤ","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"So n may take on any value between 1 and q-1 not divisible by q-1. Hence the only possible exception is n=(q-1)2 which can only occur if q is odd. It thus makes sense to consider q odd and q even separately.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"We demonstrate this for q even. Then langlechi_4chi_2^2rangle=0 and with a similar argument langlechi_5chi_2^2rangle=0. We now construct a copy of the table but with the congruence equation qequiv 0pmod 2 applied:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> T2 = set_congruence(T; remainder=0, modulus=2);","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Inspecting the list of exceptions for langlechi_6chi_2^2rangle, the first occurs when q-1 divides m+n. To study this case we specialize m for character type 6:","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> (q, (a, b, m, n)) = parameters(T2);\n\njulia> x = parameter(T2, \"x\");  # create an additional \"free\" variable\n\njulia> s = specialize(T2[6], m, -n + (q-1)*x);  # force m = -n (mod q-1)","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Recomputing the scalar product now gives a new result. Note that we have to map the character type h into the new table for this to work.","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"julia> scalar_product(s, T2(h))\n1\nWith exceptions:\n  3*n1 ∈ (q - 1)ℤ\n  2*n1 ∈ (q - 1)ℤ","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"The exceptions both cannot occur as q is even and the table we are considering is only defined for qnotequiv 1pmod 3. By working through the other possible exceptions and irreducible character types, and handling duplicates, one finally obtains","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"chi_2^2 = chi_1+2chi_2+2chi_3\n    +frac12sum_n=1^q-2 chi_6(nq-1-n)\n    +frac12sum_n=1^q chi_7(n(q-1))","category":"page"},{"location":"book/","page":"An extended example","title":"An extended example","text":"Where chi_6(nq-1-n) indicates that the 6th character in the table T2 is a family on two parameters: n and q-1-n, while chi_7 depends on only one, namely n(q-1). A similar result can be obtained for odd q albeit with a few more cases that need to be dealt with, but all in essentially the same manner.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"characters/#Character-types","page":"Character types","title":"Character types","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"A character type is a family of characters which are indexed by a set of parameters, together with ranges of admissible values for each parameters, and a set of excluded parameter values. The characters in a character type share many properties, e.g. they all have the same degree.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"Since \"types\" already have a very specific meaning in Julia (and other programming languages), we instead sometimes refer to character types as \"generic characters\". In particular the Julia types we use to represent character types are called AbstractGenericCharacter, GenericCharacter and SimpleGenericCharacter.","category":"page"},{"location":"characters/#Properties","page":"Character types","title":"Properties","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"number_of_character_types\nnumber_of_characters(char::GenericCharacter)\ndegree(chi::AbstractGenericCharacter)\nparameters(chi::GenericCharacter)\ninfo(char::AbstractGenericCharacter)","category":"page"},{"location":"characters/#GenericCharacterTables.number_of_character_types","page":"Character types","title":"GenericCharacterTables.number_of_character_types","text":"number_of_character_types(t::Table)\n\nReturn the number of character types of table t. This can also be obtained via length(t).\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_character_types(g)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"characters/#GenericCharacterTables.number_of_characters-Tuple{GenericCharacterTables.GenericCharacter}","page":"Character types","title":"GenericCharacterTables.number_of_characters","text":"number_of_characters(char::GenericCharacter)\n\nReturn the number of characters in the generic character char.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_characters(g[1])\nq - 1\n\n\n\n\n\n\n","category":"method"},{"location":"characters/#AbstractAlgebra.degree-Tuple{GenericCharacterTables.AbstractGenericCharacter}","page":"Character types","title":"AbstractAlgebra.degree","text":"degree(char::AbstractGenericCharacter)\n\nReturn the character degree of the characters in char.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> degree(g[3])\nq + 1\n\n\n\n\n\n\n","category":"method"},{"location":"characters/#GenericCharacterTables.parameters-Tuple{GenericCharacterTables.GenericCharacter}","page":"Character types","title":"GenericCharacterTables.parameters","text":"parameters(char::AbstractGenericCharacter)\n\nReturn the parameters of the character type char. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(g[3])\nk ∈ {1,…, q - 1}, l ∈ {1,…, q - 1} except -l + k ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"characters/#GenericCharacterTables.info-Tuple{GenericCharacterTables.AbstractGenericCharacter}","page":"Character types","title":"GenericCharacterTables.info","text":"info(char::AbstractGenericCharacter)\n\nReturn the infolists of the character type char.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> info(g[2])\n2-element Vector{Any}:\n Any[1, 1]\n Any[\"A_1\", [1, 1]]\n\n\n\n\n\n\n","category":"method"},{"location":"characters/#Iteration","page":"Character types","title":"Iteration","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"Character types behave in some ways similar to Julia Vector objects in that one can index into them to extract values. For a character type ct,","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"length(ct) returns the number of values in the character type (which is equal to the number  of class types s in the table),\nct[i] returns the ith value of the character type,\nct[i:j] returns the values i to j,\nct[:] returns all values.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"The ith character type can be obtained from a generic character table g in two ways: via g[i] or via g[i,:]. The following example demonstrates this.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"julia> g=generic_character_table(\"GL2\");\n\njulia> g[3,:]\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}, l ∈ {1,…, q - 1} except -l + k ∈ (q - 1)ℤ\n  of degree q + 1\n  with values\n    1: (q + 1)*E(q - 1)^(i*l + i*k)\n    2: E(q - 1)^(i*l + i*k)\n    3: E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n    4: 0\n\njulia> ct = g[3]\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}, l ∈ {1,…, q - 1} except -l + k ∈ (q - 1)ℤ\n  of degree q + 1\n  with values\n    1: (q + 1)*E(q - 1)^(i*l + i*k)\n    2: E(q - 1)^(i*l + i*k)\n    3: E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n    4: 0\n\njulia> ct[1]\n(q + 1)*E(q - 1)^(i*l + i*k)\n\njulia> ct[1:3]\n3-element Vector{GenericCharacterTables.GenericCyclo}:\n (q + 1)*E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n\njulia> ct[2:end]\n3-element Vector{GenericCharacterTables.GenericCyclo}:\n E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n 0\n\njulia> collect(ct)\n4-element Vector{GenericCharacterTables.GenericCyclo}:\n (q + 1)*E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n 0\n\njulia> ct[:]\n4-element Vector{GenericCharacterTables.GenericCyclo}:\n (q + 1)*E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + i*k)\n E(q - 1)^(i*l + j*k) + E(q - 1)^(i*k + j*l)\n 0\n","category":"page"},{"location":"characters/#Parameter-names","page":"Character types","title":"Parameter names","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"When two characters types are for example added together or multiplied with each other, it is necessary to differentiate the parameters of the two character types. Otherwise the result will only represent a fraction of all possible combinations of characters. Namely those where the parameters of the character types with identical name have the same value. Therefore the parameter k will be called kti whenever it represents the parameter k of the i-th character type of a tensor product. Similarly it will be called kli in a linear combination and ki in a scalar product.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"Note that for linear combinations this has the possibly unexpected implication that 2chi represents the character type containing the double of each character contained in chi while chi+chi represents the character type containing every possible sum of two characters in chi.","category":"page"},{"location":"characters/#Constructing-new-character-types","page":"Character types","title":"Constructing new character types","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"The immediate way to obtain a character type object is to get it from a  table T via indexing, i.e., as T[i] for some index i.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"In addition, there are a few ways to construct new character types.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"tensor_product(char1::GenericCharacter, char2::GenericCharacter)\ntensor_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T <: PolyRingElem\nlinear_combination\nomega","category":"page"},{"location":"characters/#Hecke.tensor_product-Tuple{GenericCharacterTables.GenericCharacter, GenericCharacterTables.GenericCharacter}","page":"Character types","title":"Hecke.tensor_product","text":"tensor_product(char1::GenericCharacter, char2::GenericCharacter)\n\nReturn the tensor product of the character types char1 and char2. This can also be obtained via char1 * char2.\n\nExamples\n\njulia> g = generic_character_table(\"GL2\");\n\njulia> tensor_product(g[1], g[2])\nGeneric character of GL2\n  with parameters\n    kt1 ∈ {1,…, q - 1}, kt2 ∈ {1,…, q - 1}\n  of degree q\n  with values\n    1: q*E(q - 1)^(2*i*kt1 + 2*i*kt2)\n    2: 0\n    3: E(q - 1)^(i*kt1 + i*kt2 + j*kt1 + j*kt2)\n    4: -E(q - 1)^(i*kt1 + i*kt2)\n\n\n\n\n\n","category":"method"},{"location":"characters/#Hecke.tensor_product-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleGenericCharacter{T}, GenericCharacterTables.SimpleGenericCharacter{T}}} where T<:AbstractAlgebra.PolyRingElem","page":"Character types","title":"Hecke.tensor_product","text":"tensor_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T<:PolyRingElem\n\nReturn the tensor product of the character types char1 and char2. This can also be obtained via char1 * char2.\n\nExamples\n\njulia> g = green_function_table(\"GL3\");\n\njulia> tensor_product(g[1],g[2])\nGeneric character of GL3\n  of degree -q^6 - 2*q^5 - 2*q^4 + 2*q^2 + 2*q + 1\n  with values\n    1: -q^6 - 2*q^5 - 2*q^4 + 2*q^2 + 2*q + 1\n    2: 2*q + 1\n    3: 1\n\n\n\n\n\n","category":"method"},{"location":"characters/#GenericCharacterTables.linear_combination","page":"Character types","title":"GenericCharacterTables.linear_combination","text":"linear_combination(coeffs::Vector{<:RingElement}, chars::Vector{<:GenericCharacter})\n\nReturn the linear combination of the character types chars with coefficients coeffs.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> linear_combination([5,1],[g[1],g[2]])\nGeneric character of GL2\n  with parameters\n    kl1 ∈ {1,…, q - 1}, kl2 ∈ {1,…, q - 1}\n  of degree q + 5\n  with values\n    1: 5*E(q - 1)^(2*i*kl1) + q*E(q - 1)^(2*i*kl2)\n    2: 5*E(q - 1)^(2*i*kl1)\n    3: E(q - 1)^(i*kl2 + j*kl2) + 5*E(q - 1)^(i*kl1 + j*kl1)\n    4: -E(q - 1)^(i*kl2) + 5*E(q - 1)^(i*kl1)\n\n\n\n\n\nlinear_combination(coeffs::Vector{<:RingElement}, chars::Vector{SimpleGenericCharacter{T}}) where T <: NfPoly\n\nReturn the linear combination of the character types chars with coefficients coeffs.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> linear_combination([5,1],[g[1],g[2]])\nGeneric character of GL3\n  of degree 4*q^3 + 10*q^2 + 10*q + 6\n  with values\n    1: 4*q^3 + 10*q^2 + 10*q + 6\n    2: 10*q + 6\n    3: 6\n\n\n\n\n\n","category":"function"},{"location":"characters/#GenericCharacterTables.omega","page":"Character types","title":"GenericCharacterTables.omega","text":"omega(char::GenericCharacter)\n\nReturn the (generic) central character of the character type char.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> omega(g[1])\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}\n  of degree 1\n  with values\n    1: E(q - 1)^(2*i*k)\n    2: (q^2 - 1)*E(q - 1)^(2*i*k)\n    3: (q^2 + q)*E(q - 1)^(i*k + j*k)\n    4: (q^2 - q)*E(q - 1)^(i*k)\n\n\n\n\n\n\nomega(char::SimpleGenericCharacter{T}) where T <: NfPoly\n\nReturn the (generic) central character of the character type char.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> omega(g[1])\nGeneric character of GL3\n  of degree 1\n  with values\n    1: 1\n    2: 2*q^2 - q - 1\n    3: q^3 - 2*q^2 + q\n\n\n\n\n\n","category":"function"},{"location":"characters/#Norms-and-scalar-products","page":"Character types","title":"Norms and scalar products","text":"","category":"section"},{"location":"characters/","page":"Character types","title":"Character types","text":"GenericCharacterTables allows you to compute norms and scalar products of character types. The results are correct for all possible combinations of parameters except possibly for those where the additionally returned exceptions apply. Those consist of multivariate polynomials with coefficients in a rational function field and are satisfied if the evaluation of this polynomial is an integer.","category":"page"},{"location":"characters/","page":"Character types","title":"Character types","text":"norm(char::GenericCharacter)\nnorm(char::SimpleGenericCharacter{T}) where T <: NfPoly\nscalar_product(char1::GenericCharacter, char2::GenericCharacter)\nscalar_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T <: NfPoly","category":"page"},{"location":"characters/#LinearAlgebra.norm-Tuple{GenericCharacterTables.GenericCharacter}","page":"Character types","title":"LinearAlgebra.norm","text":"norm(char::GenericCharacter)\n\nReturn the norm of the character type char.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> norm(g[1])\n1\n\n\n\n\n\n","category":"method"},{"location":"characters/#LinearAlgebra.norm-Union{Tuple{GenericCharacterTables.SimpleGenericCharacter{T}}, Tuple{T}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Character types","title":"LinearAlgebra.norm","text":"norm(char::SimpleGenericCharacter{T}) where T <: NfPoly\n\nReturn the norm of the character type char.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> norm(g[1])\n6//(q^3 - 3*q^2 + 3*q - 1)\n\n\n\n\n\n","category":"method"},{"location":"characters/#Oscar.scalar_product-Tuple{GenericCharacterTables.GenericCharacter, GenericCharacterTables.GenericCharacter}","page":"Character types","title":"Oscar.scalar_product","text":"scalar_product(char1::GenericCharacter, char2::GenericCharacter)\n\nReturn the scalar product between the character types char1 and char2.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> scalar_product(g[3],g[2])\n0\nWith exceptions:\n  l1 + k1 - 2*k2 ∈ (q - 1)ℤ\n  l1 - k2 ∈ (q - 1)ℤ\n  k1 - k2 ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"characters/#Oscar.scalar_product-Union{Tuple{T}, Tuple{GenericCharacterTables.SimpleGenericCharacter{T}, GenericCharacterTables.SimpleGenericCharacter{T}}} where T<:Union{AbstractAlgebra.PolyRingElem{Nemo.AbsSimpleNumFieldElem}, AbstractAlgebra.PolyRingElem{Nemo.QQFieldElem}}","page":"Character types","title":"Oscar.scalar_product","text":"scalar_product(char1::SimpleGenericCharacter{T}, char2::SimpleGenericCharacter{T}) where T <: NfPoly\n\nReturn the scalar product between the character types char1 and char2.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> scalar_product(g[1],g[2])\n0\n\n\n\n\n\n","category":"method"},{"location":"modify/","page":"Specializing parameters","title":"Specializing parameters","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"modify/#Specializing-parameters","page":"Specializing parameters","title":"Specializing parameters","text":"","category":"section"},{"location":"modify/","page":"Specializing parameters","title":"Specializing parameters","text":"Sometimes one likes to specify some of the free variables in the tables to simplify the often very complicated values a bit.","category":"page"},{"location":"modify/","page":"Specializing parameters","title":"Specializing parameters","text":"set_congruence\nspecialize","category":"page"},{"location":"modify/#GenericCharacterTables.set_congruence","page":"Specializing parameters","title":"GenericCharacterTables.set_congruence","text":"set_congruence(x::CharTable, congruence::Tuple{ZZRingElem, ZZRingElem})\n\nReturn a new generic character table based on x where the main parameter is additionally assumed to be congruent to congruence[1] modulo congruence[2]. So the entries of x can potentially be simplified further.\n\n\n\n\n\nset_congruence(x::CharTable; remainder::Union{Int, ZZRingElem}, modulus::Union{Int, ZZRingElem})\n\nReturn a new generic character table based on x where the main parameter is additionally assumed to be congruent to remainder modulo modulus. So the entries of x can potentially be simplified further. All existing congruences in x will be preserved. This function is usefull for decomposing tensor products.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\")\nGeneric character table GL2\n  of order q^4 - q^3 - q^2 + q\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\njulia> set_congruence(g; remainder=0, modulus=2)\nGeneric character table GL2*\n  of order q^4 - q^3 - q^2 + q\n  restricted to q congruent to 0 modulo 2\n  with 4 irreducible character types\n  with 4 class types\n  with parameters (i, j, l, k)\n\n\n\n\n\n","category":"function"},{"location":"modify/#GenericCharacterTables.specialize","page":"Specializing parameters","title":"GenericCharacterTables.specialize","text":"specialize(class::GenericConjugacyClass, var::UPoly, expr::RingElement)\n\nReturn the generic conjugacy class where the parameter var is replaced with expr in class.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> conjugacy_class_type(g, 1)\nGeneric conjugacy class of GL2\n  with parameters\n    i ∈ {1,…, q - 1}\n  of order 1\n  with values\n    1: E(q - 1)^(2*i*k)\n    2: q*E(q - 1)^(2*i*k)\n    3: (q + 1)*E(q - 1)^(i*l + i*k)\n    4: (q - 1)*E(q - 1)^(i*k)\n\njulia> q,(i,j,l,k) = parameters(g);\n\njulia> specialize(conjugacy_class_type(g, 1), i, q)\nGeneric conjugacy class of GL2\n  with parameters\n    i ∈ {1,…, q - 1}, substitutions: i = q\n  of order 1\n  with values\n    1: E(q - 1)^(2*k)\n    2: q*E(q - 1)^(2*k)\n    3: (q + 1)*E(q - 1)^(l + k)\n    4: (q - 1)*E(q - 1)^k\n\n\n\n\n\nspecialize(char::GenericCharacter, var::UPoly, expr::RingElement)\n\nReturn the generic character where the parameter var is replaced with expr in char.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> g[1]\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}\n  of degree 1\n  with values\n    1: E(q - 1)^(2*i*k)\n    2: E(q - 1)^(2*i*k)\n    3: E(q - 1)^(i*k + j*k)\n    4: E(q - 1)^(i*k)\n\njulia> q,(i,j,l,k) = parameters(g);\n\njulia> specialize(g[1], i, q)\nGeneric character of GL2\n  with parameters\n    k ∈ {1,…, q - 1}, substitutions: i = q\n  of degree 1\n  with values\n    1: E(q - 1)^(2*k)\n    2: E(q - 1)^(2*k)\n    3: E(q - 1)^(j*k + k)\n    4: E(q - 1)^k\n\n\n\n\n\n\n","category":"function"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"CurrentModule = GenericCharacterTables\nDocTestSetup = :(using GenericCharacterTables, Oscar)","category":"page"},{"location":"classes/#Conjugacy-class-types","page":"Conjugacy class types","title":"Conjugacy class types","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"A class type is a family of conjugacy classes which are indexed by a set of parameters, together with ranges of admissible values for each parameters, and a set of excluded parameter values.","category":"page"},{"location":"classes/#Properties","page":"Conjugacy class types","title":"Properties","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"conjugacy_class_type\nnumber_of_conjugacy_class_types\nnumber_of_conjugacy_classes(t::Table)\nnumber_of_conjugacy_classes(class::GenericConjugacyClass)\nnumber_of_conjugacy_classes(class::SimpleGenericConjugacyClass)\nnumber_of_conjugacy_classes(t::Table, class::Int64)\norder(class::AbstractGenericConjugacyClass)\norder(t::Table, class::Int64)\ncentralizer_order\nparameters(class::GenericConjugacyClass)\nparameters(class::SimpleGenericConjugacyClass)\nparameters(t::Table, class::Int64)\ninfo(class::GenericConjugacyClass)\ninfo(class::SimpleGenericConjugacyClass)\ninfo(t::Table, class::Int64)","category":"page"},{"location":"classes/#GenericCharacterTables.conjugacy_class_type","page":"Conjugacy class types","title":"GenericCharacterTables.conjugacy_class_type","text":"conjugacy_class_type(t::CharTable, class::Int64)\n\nReturn the generic conjugacy class class of t.\n\n\n\n\n\nconjugacy_class_type(t::SimpleCharTable{T}, class::Int64) where T <: NfPoly\n\nReturn the generic conjugacy class class of t.\n\n\n\n\n\n","category":"function"},{"location":"classes/#GenericCharacterTables.number_of_conjugacy_class_types","page":"Conjugacy class types","title":"GenericCharacterTables.number_of_conjugacy_class_types","text":"number_of_conjugacy_class_types(t::Table)\n\nReturn the number of conjugacy class types of table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_conjugacy_class_types(g)\n4\n\n\n\n\n\n\n","category":"function"},{"location":"classes/#Oscar.number_of_conjugacy_classes-Tuple{GenericCharacterTables.Table}","page":"Conjugacy class types","title":"Oscar.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(t::Table)\n\nReturn the number of conjugacy classes of table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_conjugacy_classes(g)\nq^2 - 1\n\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.number_of_conjugacy_classes-Tuple{GenericCharacterTables.GenericConjugacyClass}","page":"Conjugacy class types","title":"Oscar.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(class::GenericConjugacyClass)\n\nReturn the number of conjugacy classes in class.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_conjugacy_classes(conjugacy_class_type(g, 1))\nq - 1\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.number_of_conjugacy_classes-Tuple{GenericCharacterTables.SimpleGenericConjugacyClass}","page":"Conjugacy class types","title":"Oscar.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(class::SimpleGenericConjugacyClass)\n\nReturn the number of conjugacy classes in class.\n\nExamples\n\njulia> g=green_function_table(\"GL2\");\n\njulia> number_of_conjugacy_classes(conjugacy_class_type(g, 1))\n1\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.number_of_conjugacy_classes-Tuple{GenericCharacterTables.Table, Int64}","page":"Conjugacy class types","title":"Oscar.number_of_conjugacy_classes","text":"number_of_conjugacy_classes(t::Table, class::Int64)\n\nReturn the number of conjugacy classes in the class type class of the table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> number_of_conjugacy_classes(g, 1)\nq - 1\n\n\n\n\n\n","category":"method"},{"location":"classes/#AbstractAlgebra.order-Tuple{GenericCharacterTables.AbstractGenericConjugacyClass}","page":"Conjugacy class types","title":"AbstractAlgebra.order","text":"order(class::AbstractGenericConjugacyClass)\n\nReturn the order of the conjugacy classes in class.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> order(conjugacy_class_type(g, 3))\nq^2 + q\n\n\n\n\n\n","category":"method"},{"location":"classes/#AbstractAlgebra.order-Tuple{GenericCharacterTables.Table, Int64}","page":"Conjugacy class types","title":"AbstractAlgebra.order","text":"order(t::Table, class::Int64)\n\nReturn the order of the conjugacy classes in the class type class of t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> order(g, 3)\nq^2 + q\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.centralizer_order","page":"Conjugacy class types","title":"GenericCharacterTables.centralizer_order","text":"centralizer_order(class::AbstractGenericConjugacyClass)\n\nReturn the order of the centralizer of the class type class.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> centralizer_order(conjugacy_class_type(g, 1))\nq^4 - q^3 - q^2 + q\n\n\n\n\n\n\ncentralizer_order(t::Table, class::Int64)\n\nReturn the order of the centralizer of the class type class of the table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> centralizer_order(g, 1)\nq^4 - q^3 - q^2 + q\n\n\n\n\n\n\n","category":"function"},{"location":"classes/#GenericCharacterTables.parameters-Tuple{GenericCharacterTables.GenericConjugacyClass}","page":"Conjugacy class types","title":"GenericCharacterTables.parameters","text":"parameters(class::GenericConjugacyClass)\n\nReturn the parameters of the conjugacy class type class. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(conjugacy_class_type(g, 3))\ni ∈ {1,…, q - 1}, j ∈ {1,…, q - 1} except i - j ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.parameters-Tuple{GenericCharacterTables.SimpleGenericConjugacyClass}","page":"Conjugacy class types","title":"GenericCharacterTables.parameters","text":"parameters(class::SimpleGenericConjugacyClass)\n\nReturn the parameters of the conjugacy class type class. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"uniGL2\");\n\njulia> parameters(conjugacy_class_type(g, 1))\n\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.parameters-Tuple{GenericCharacterTables.Table, Int64}","page":"Conjugacy class types","title":"GenericCharacterTables.parameters","text":"parameters(t::Table, class::Int64)\n\nReturn the parameters of the class type class of the table t. This includes the parameter names, ranges and exceptions.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> parameters(g, 3)\ni ∈ {1,…, q - 1}, j ∈ {1,…, q - 1} except i - j ∈ (q - 1)ℤ\n\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.info-Tuple{GenericCharacterTables.GenericConjugacyClass}","page":"Conjugacy class types","title":"GenericCharacterTables.info","text":"info(class::AbstractGenericConjugacyClass)\n\nReturn the infolists of the generic conjugacy class class.\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.info-Tuple{GenericCharacterTables.SimpleGenericConjugacyClass}","page":"Conjugacy class types","title":"GenericCharacterTables.info","text":"info(class::AbstractGenericConjugacyClass)\n\nReturn the infolists of the generic conjugacy class class.\n\n\n\n\n\n","category":"method"},{"location":"classes/#GenericCharacterTables.info-Tuple{GenericCharacterTables.Table, Int64}","page":"Conjugacy class types","title":"GenericCharacterTables.info","text":"info(t::Table, class::Int64)\n\nReturn the infolists of the class type class of the table t.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> info(g, 1)\n2-element Vector{Any}:\n Any[1, 0]\n Any[\"A_1\", [1, 1]]\n\n\n\n\n\n\n","category":"method"},{"location":"classes/#Norms-and-scalar-products","page":"Conjugacy class types","title":"Norms and scalar products","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"GenericCharacterTables allows you to compute norms and scalar products of class types. The results are correct for all possible combinations of parameters except possibly for those where the additionally returned exceptions apply. Those consist of multivariate polynomials with coefficients in a rational function field and are satisfied if the evaluation of this polynomial is an integer.","category":"page"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"norm(class::GenericConjugacyClass)\nnorm(class::SimpleGenericConjugacyClass)\nnorm(t::Table, class::Int64)\nscalar_product(class1::GenericConjugacyClass, class2::GenericConjugacyClass)\nscalar_product(class1::SimpleGenericConjugacyClass, class2::SimpleGenericConjugacyClass)\nscalar_product(t::Table, class1::Int64, class2::Int64)\nclass_multiplication_coefficient(class1::SimpleGenericConjugacyClass, class2::SimpleGenericConjugacyClass, class3::SimpleGenericConjugacyClass)\nclass_multiplication_coefficient(class1::GenericConjugacyClass, class2::GenericConjugacyClass, class3::GenericConjugacyClass)\nclass_multiplication_coefficient(t::Table, class1::Int64, class2::Int64, class3::Int64)","category":"page"},{"location":"classes/#LinearAlgebra.norm-Tuple{GenericCharacterTables.GenericConjugacyClass}","page":"Conjugacy class types","title":"LinearAlgebra.norm","text":"norm(class::GenericConjugacyClass)\n\nReturn the (generic) norm of class.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> norm(conjugacy_class_type(g, 2))\n1\n\n\n\n\n\n","category":"method"},{"location":"classes/#LinearAlgebra.norm-Tuple{GenericCharacterTables.SimpleGenericConjugacyClass}","page":"Conjugacy class types","title":"LinearAlgebra.norm","text":"norm(class::SimpleGenericConjugacyClass)\n\nReturn the (generic) norm of class.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> norm(conjugacy_class_type(g, 2))\n(5*q^2 + 2*q + 3)//(q^5 - 2*q^4 + q^3)\n\n\n\n\n\n","category":"method"},{"location":"classes/#LinearAlgebra.norm-Tuple{GenericCharacterTables.Table, Int64}","page":"Conjugacy class types","title":"LinearAlgebra.norm","text":"norm(t::Table, class::Int64)\n\nReturn the (generic) norm of the class type class.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> norm(g,2)\n1\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.scalar_product-Tuple{GenericCharacterTables.GenericConjugacyClass, GenericCharacterTables.GenericConjugacyClass}","page":"Conjugacy class types","title":"Oscar.scalar_product","text":"scalar_product(class1::GenericConjugacyClass, class2::GenericConjugacyClass)\n\nReturn the (generic) scalar product between class1 and class2.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> scalar_product(conjugacy_class_type(g, 3), conjugacy_class_type(g, 2))\n0\nWith exceptions:\n  i1 + j1 - 2*i2 ∈ (q - 1)ℤ\n  i1 - i2 ∈ (q - 1)ℤ\n  j1 - i2 ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.scalar_product-Tuple{GenericCharacterTables.SimpleGenericConjugacyClass, GenericCharacterTables.SimpleGenericConjugacyClass}","page":"Conjugacy class types","title":"Oscar.scalar_product","text":"scalar_product(class1::SimpleGenericConjugacyClass, class2::SimpleGenericConjugacyClass)\n\nReturn the (generic) scalar product between class1 and class2.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> scalar_product(conjugacy_class_type(g, 2), conjugacy_class_type(g, 2))\n(5*q^2 + 2*q + 3)//(q^5 - 2*q^4 + q^3)\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.scalar_product-Tuple{GenericCharacterTables.Table, Int64, Int64}","page":"Conjugacy class types","title":"Oscar.scalar_product","text":"scalar_product(t::Table, class1::Int64, class2::Int64)\n\nReturn the (generic) scalar product between the class types class1 and class2.\n\nExamples\n\njulia> g=generic_character_table(\"GL2\");\n\njulia> scalar_product(g,3,2)\n0\nWith exceptions:\n  i1 + j1 - 2*i2 ∈ (q - 1)ℤ\n  i1 - i2 ∈ (q - 1)ℤ\n  j1 - i2 ∈ (q - 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.class_multiplication_coefficient-Tuple{GenericCharacterTables.SimpleGenericConjugacyClass, GenericCharacterTables.SimpleGenericConjugacyClass, GenericCharacterTables.SimpleGenericConjugacyClass}","page":"Conjugacy class types","title":"Oscar.class_multiplication_coefficient","text":"class_multiplication_coefficient(class1::SimpleGenericConjugacyClass, class2::SimpleGenericConjugacyClass, class3::SimpleGenericConjugacyClass)\n\nReturn the (generic) class multiplication coefficient of class1, class2 and class3.\n\nExamples\n\njulia> g=green_function_table(\"GL3\");\n\njulia> class_multiplication_coefficient(conjugacy_class_type(g, 1), conjugacy_class_type(g, 2), conjugacy_class_type(g, 3))\n(q + 3)//(q^5 - 2*q^4 + q^3)\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.class_multiplication_coefficient-Tuple{GenericCharacterTables.GenericConjugacyClass, GenericCharacterTables.GenericConjugacyClass, GenericCharacterTables.GenericConjugacyClass}","page":"Conjugacy class types","title":"Oscar.class_multiplication_coefficient","text":"class_multiplication_coefficient(class1::GenericConjugacyClass, class2::GenericConjugacyClass, class3::GenericConjugacyClass)\n\nReturn the (generic) class multiplication coefficient of class1, class2 and class3.\n\nExamples\n\njulia> g=generic_character_table(\"SL2.0\");\n\njulia> class_multiplication_coefficient(conjugacy_class_type(g, 2), conjugacy_class_type(g, 2), conjugacy_class_type(g, 4))\nq + 1\nWith exceptions:\n  a3 ∈ (q + 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"classes/#Oscar.class_multiplication_coefficient-Tuple{GenericCharacterTables.Table, Int64, Int64, Int64}","page":"Conjugacy class types","title":"Oscar.class_multiplication_coefficient","text":"class_multiplication_coefficient(t::Table, class1::Int64, class2::Int64, class3::Int64)\n\nReturn the (generic) class multiplication coefficient of the class types class1, class2 and class3 of the table t.\n\nExamples\n\njulia> g=generic_character_table(\"SL2.0\");\n\njulia> class_multiplication_coefficient(g,2,2,4)\nq + 1\nWith exceptions:\n  a3 ∈ (q + 1)ℤ\n\n\n\n\n\n","category":"method"},{"location":"classes/#Iteration","page":"Conjugacy class types","title":"Iteration","text":"","category":"section"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"To get a specific conjugacy class type one can also use the indexing features of generic character tables. Moreover the conjugacy class type itself implements the standard iteration and indexing interfaces and can thus be treated similarly to a Vector object.","category":"page"},{"location":"classes/","page":"Conjugacy class types","title":"Conjugacy class types","text":"julia> g=generic_character_table(\"GL2\");\n\njulia> cl=g[:,1]\nGeneric conjugacy class of GL2\n  with parameters\n    i ∈ {1,…, q - 1}\n  of order 1\n  with values\n    1: E(q - 1)^(2*i*k)\n    2: q*E(q - 1)^(2*i*k)\n    3: (q + 1)*E(q - 1)^(i*l + i*k)\n    4: (q - 1)*E(q - 1)^(i*k)\n\njulia> cl[1]\nE(q - 1)^(2*i*k)\n\njulia> cl[2:3]\n2-element Vector{GenericCharacterTables.GenericCyclo}:\n q*E(q - 1)^(2*i*k)\n (q + 1)*E(q - 1)^(i*l + i*k)\n\njulia> cl[:]\n4-element Vector{GenericCharacterTables.GenericCyclo}:\n E(q - 1)^(2*i*k)\n q*E(q - 1)^(2*i*k)\n (q + 1)*E(q - 1)^(i*l + i*k)\n (q - 1)*E(q - 1)^(i*k)\n\njulia> for v in cl\n           println(v)\n       end\nE(q - 1)^(2*i*k)\nq*E(q - 1)^(2*i*k)\n(q + 1)*E(q - 1)^(i*l + i*k)\n(q - 1)*E(q - 1)^(i*k)\n","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"#GenericCharacterTables.jl","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"","category":"section"},{"location":"#About","page":"GenericCharacterTables.jl","title":"About","text":"","category":"section"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"GenericCharacterTables is a library for working with generic character tables. It is based on CHEVIE and aims to provide all its features originally implemented in Maple. It is written in Julia and depends on Nemo and therefore on AbstractAlgebra.","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"For the mathematical background, consider that there are many interesting families of finite groups. For example, the matrix groups mathrmGL_n(mathbbF_q) or mathrmSL_n(mathbbF_q), for n1 and q a prime power. These groups have many properties in common. It turns out that for a fixed rank (say n=2) it is possible to parametrize the conjugacy classes and irreducible characters of these group in terms of q, and to write this down into a so-called generic character table. This was first done by Schur for mathrmSL_2(mathbbF_q).","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"This package provides code to interact with such generic character tables, and also includes many such tables. The code in this package is based on Maple code included in the CHEVIE project.","category":"page"},{"location":"","page":"GenericCharacterTables.jl","title":"GenericCharacterTables.jl","text":"For more details about the mathematical background, see [GHLMP96].","category":"page"},{"location":"cyclo/","page":"Generic cyclotomics","title":"Generic cyclotomics","text":"CurrentModule = GenericCharacterTables","category":"page"},{"location":"cyclo/#Generic-cyclotomics","page":"Generic cyclotomics","title":"Generic cyclotomics","text":"","category":"section"},{"location":"cyclo/","page":"Generic cyclotomics","title":"Generic cyclotomics","text":"TODO: this file should contain information about generic cyclotomics: what these are, how to work with them; what is and isn't implemented.","category":"page"}]
}
